/* autogenerated by Processing revision 1292 on 2023-07-28 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.time.*;
import java.util.*;
import java.io.*;
import java.nio.*;
import processing.net.*;
import java.awt.Toolkit;
import java.awt.datatransfer.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class MTC_to_Simulink_Adapter_Analysis_Differential extends PApplet {







final PApplet APP = this;
ArrayList<Mode> modes = new ArrayList<Mode>();

// Options
boolean DUMMY = false;
long MAX_MTC_SAMPLES = 10000;
int SERVER_PORT = 16385;
String MTC_IP = "127.0.0.1";
int MTC_port = 5000;
//String MTC_UR5e_NAME = "UR5e";
String MTC_UR5e_UUID = "ur5e";
double MTC_QUERY_INTERVAL = 5; // seconds
boolean SAVE_REPLAY = true;
double SAVE_REPLAY_INTERVAL = 30; // seconds
boolean SAVE_MTC = false;
boolean AUTOPLAY = false;
float TIME_DATA_DURATION = 10; // seconds
float TCP_POS_ERROR_THRESHOLD = 0.01f; // meters
float TCP_POS_ERROR_DURATION = 10; // seconds
float TCP_ROT_ERROR_THRESHOLD = 0.01f; // radians
float TCP_ROT_ERROR_DURATION = 10; // seconds
float JOINT_ERROR_THRESHOLD = 0.01f; // radians
float JOINT_ERROR_DURATION = 10; // seconds

// Timekeeping
long pTime;
double deltaTime;
double timeScale = 1;
double mtc_query_timer = 0;
double save_replay_timer = 0;

// Networking
Server server;
Client mtc_client;

// Robot control and analysis
long MTC_lastSequenceNum = -1; // the last processed sequence number
SamplePlayback playback;
boolean playing = false, step = false;
LocalDateTime ur_sim_time = LocalDateTime.MIN;
UR_State simstate = new UR_State();
UR_State realstate = new UR_State();

Table dataTable;

public void init_MTC() {
  String command = String.format("curl %s:%d/%s/current", MTC_IP, MTC_port, MTC_UR5e_UUID);
  XML doc = null;

  try {
    Process process = Runtime.getRuntime().exec(command);
    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
    StringBuilder sb = new StringBuilder();
    String line;
    while ((line = reader.readLine()) != null) {
      sb.append(line);
      sb.append('\n');
    }
    reader.close();
    doc = XML.parse(sb.toString());
  }
  catch (Exception e) {
    e.printStackTrace();
  }
  if (doc == null) {
    throw new RuntimeException("Could not initialize MTConnect adapter, no connection. Make sure curl is installed and on the PATH.");
  }
  XML header = doc.getChild("Header");
  long last = header.getLong("lastSequence", -1);
  if (last >= 0) {
    MTC_lastSequenceNum = last;
    println("Most recent sequence number: " + MTC_lastSequenceNum);
  } else {
    throw new RuntimeException("Error in MTConnect query");
  }
}

public void query_UR_data() {
  String command = String.format(
    "curl %s:%d/%s/sample?from=%d&count=%d",
    MTC_IP,
    MTC_port,
    MTC_UR5e_UUID,
    Math.max(MTC_lastSequenceNum-100, 0), // minus 100 to have buffer
    MAX_MTC_SAMPLES);
  XML doc = null;

  try {
    Process process = Runtime.getRuntime().exec(command);
    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
    StringBuilder sb = new StringBuilder();
    String line;
    while ((line = reader.readLine()) != null) {
      sb.append(line);
      sb.append('\n');
    }
    reader.close();
    //println(sb.toString());
    doc = XML.parse(sb.toString());
  }
  catch (Exception e) {
    e.printStackTrace();
  }
  
  if (doc == null) return;
  
  XML header = doc.getChild("Header");
  if (header != null) {
    long last = header.getLong("lastSequence", -1);
    if (last >= 0) {
      MTC_lastSequenceNum = Math.min(last, MTC_lastSequenceNum+MAX_MTC_SAMPLES);
    } else {
      XML error_parent = doc.getChild("Errors");
      if (error_parent != null) {
        XML[] errors = error_parent.getChildren("Error");
        for(XML x : errors) {
          String errcode = x.getString("errorCode");
          if (("OUT_OF_RANGE").equals(errcode)) {
            // Reset the last sample time and the playback time to re-synchronize
            playback.time = LocalDateTime.MIN;
            init_MTC();
          }
        }
      }
    }
  }
  append_UR_data(doc);
}

public void save_data_table() {
  if (dataTable != null) {
    synchronized(dataTable) {
      if (dataTable.getRowCount() > 0) {
        String filename = String.format("Data_%d-%d-%d_%d-%d-%d.csv", year(), month(), day(), hour(), minute(), second());
        println("Saving data in file: " + filename);
        saveTable(dataTable, filename);
        dataTable.clearRows();
      }
    }
  }
}

public void append_UR_data(XML doc) {
  SampleSequence[] seq = extractUR5eData(doc, MTC_UR5e_UUID);
  if (seq == null) return;
  
  //println("Loaded UR5e data:");
  //for (SampleSequence s : seq) {
  //  print(s.dataItemId);
  //  print(" (");
  //  if (s.data.isEmpty()) {
  //    print("no data");
  //  } else {
  //    print(s.data.firstKey());
  //  }
  //  print(") : ");
  //  println(s.data.size());
  //}
  

  playback.enqueue(seq);
  if (AUTOPLAY) {
    AUTOPLAY = false; // only do this for the first time
    // Start playing one query interval after launch
    // so we have some buffer time and aren't left without data.
    Thread t = new Thread(() -> {
      try {
        Thread.sleep((long)(1000L*MTC_QUERY_INTERVAL));
      }
      catch (Exception e) {
      }
      playing = true;
    }
    );
    t.start();
  }
  if (SAVE_MTC) {
    saveXML(doc, dataPath(String.format("MTC_%d-%d-%d_%d-%d-%d.xml", year(), month(), day(), hour(), minute(), second())));
  }
}

public void setup() {
  /* size commented out by preprocessor */;
  registerMethod("mouseEvent", this);
  JSONObject config = loadJSONObject("config.json");
  float sendRate = config.getFloat("send_hz", 50);
  timeScale = config.getFloat("timescale", 1);
  MTC_IP = config.getString("MTC_ip", "127.0.0.1");
  MTC_port = config.getInt("MTC_port", 5000);
  MTC_QUERY_INTERVAL = config.getDouble("query_interval", 5);
  //MTC_UR5e_NAME = config.getString("ur5e_name", "UR5e");
  MTC_UR5e_UUID = config.getString("ur5e_uuid", "ur5e");
  SERVER_PORT = config.getInt("server_port", 16385);
  SAVE_REPLAY = config.getBoolean("save_replay", true);
  SAVE_REPLAY_INTERVAL = config.getDouble("save_replay_interval", 30);
  DUMMY = config.getBoolean("dummy", false);
  //DUMMY_FILE = config.getString("dummy_file", "ur_data.xml");
  JSONArray dummy_files_array = config.getJSONArray("dummy_files");
  String[] dummy_files = dummy_files_array.toStringArray();
  SAVE_MTC = config.getBoolean("MTC_dump", false);
  AUTOPLAY = config.getBoolean("autoplay", false);
  MAX_MTC_SAMPLES = Math.min(100000, (long) (500.0f * MTC_QUERY_INTERVAL) * 37); // Max UR sample rate in Hz * the number of seconds between MTC queries * number of dataitem samples
  TIME_DATA_DURATION = config.getFloat("time_data_duration", 10);
  TCP_POS_ERROR_THRESHOLD = config.getFloat("tcp_pos_error_threshold", 0.01f);
  TCP_POS_ERROR_DURATION = config.getFloat("tcp_pos_error_duration", 10);
  TCP_ROT_ERROR_THRESHOLD = config.getFloat("tcp_rot_error_threshold", 0.01f);
  TCP_ROT_ERROR_DURATION = config.getFloat("tcp_rot_error_duration", 10);
  JOINT_ERROR_THRESHOLD = config.getFloat("joint_error_threshold", 0.01f);
  JOINT_ERROR_DURATION = config.getFloat("joint_error_duration", 10);
  timedata = new TemporalData(ceil(sendRate*TIME_DATA_DURATION));
  frameRate(sendRate);
  surface.setResizable(true);
  surface.setTitle("MTConnect to Simulink Adapter");
  
  for(Mode m : modes) {
    m.setup();
  }
  switchMode(menu);
  
  textSize(14);
  textAlign(LEFT, TOP);

  if (SAVE_REPLAY) {
    dataTable = createDataTable();
  }
  playback = new SamplePlayback(37);
  if (DUMMY && dummy_files != null) {
    for(String dummy_filename: dummy_files) {
      XML dummy_data = loadXML(dummy_filename);
      if (dummy_data != null) {
        append_UR_data(dummy_data);
      }
    }
  } else {
    init_MTC();
  }

  println(String.format("Starting server on %s:%d...", Server.ip(), SERVER_PORT));
  server = new Server(this, SERVER_PORT);
  
  pTime = System.nanoTime();
}

public void draw() {
  long curTime = System.nanoTime();
  deltaTime = (curTime - pTime) * 0.000000001f;
  pTime = curTime;

  mtc_query_timer += deltaTime;
  if (mtc_query_timer > MTC_QUERY_INTERVAL) {
    mtc_query_timer = 0;
    if (!DUMMY)
      thread("query_UR_data");
  }
  save_replay_timer += deltaTime;
  if (save_replay_timer > SAVE_REPLAY_INTERVAL) {
    save_replay_timer = 0;
    thread("save_data_table");
  }

  // Compare current state to sim state
  extractStateFromPlayback(playback, realstate);
  real_states.put(playback.time, new UR_State(realstate));

  // Update state
  if (playing || step) {
    analyzeData();
    step = false;
    playback.step(deltaTime*timeScale);
  }

  // Send Joint Targets
  byte[] msg = createSimulinkMessage(playback.time, playback.state);
  server.write(msg);

  // Display Information
  background(0);
  mode.update();
  mode.draw();
  
  mode.drawUI();
}

public void exit() {
  save_data_table();
  mode.onEnd();
  super.exit();
}

public void mouseEvent(MouseEvent e) {
  mode.mouseEvent(e);
}

public void keyPressed() {
  if (key == ' ') {
    playing = !playing;
  }
  if (keyCode == RIGHT) {
    step = true;
  }
  int FKeyStart = g.isGL() ? 96 : 111; // F1 keyCode - 1
  // F1-F12 are keyCodes 97-108 inclusive
  if (keyCode == FKeyStart+1) {
    switchMode(menu);
  }
  if (keyCode == FKeyStart+2) {
    switchMode(infodump);
  }
  mode.keyPressed();
}

public void keyReleased() {
  mode.keyReleased();
}

public void keyTyped() {
  mode.keyTyped();
}

public void stepTimeScale(int step) {
  timeScale = constrain(timeScale*pow(0.75f, -step*0.1f), 1e-2f, 1e2f);
}

public void clientEvent(Client c) {
  if (c == mtc_client) {
    String xml_src = c.readString();
    //println("Recieved MTC XML:");
    //println(xml_src);
    int first_line_idx = xml_src.indexOf("<?xml");
    if (first_line_idx >= 0) {
      xml_src = xml_src.substring(first_line_idx);
      try {
        XML src = XML.parse(xml_src);
        append_UR_data(src);
      }
      catch (Exception e) {
        System.err.println("Error reading MTConnect XML");
      }
    }
  } else { // Assume that the client is one of the server connections, which we expect to be Simulink.
    readSimulinkResponse(c);
  }
}

public void serverEvent(Server s, Client c) {
  println("Client at " + c.ip() + " connected to server.");
  s.active();
}

public double lerp(double a, double b, double t) {
  return a + (b-a)*t;
}

public double invlerp(double a, double b, double v) {
  return (v-a)/(b-a);
}

public double map(double v, double a1, double b1, double a2, double b2) {
  return lerp(a2, b2, invlerp(a1, b1, v));
}

public double constrain(double v, double lo, double hi) {
  return Math.max(Math.min(v, hi), lo);
}
ArrayList<Double> analysis = new ArrayList<>();
TreeMap<LocalDateTime, UR_State> real_states = new TreeMap<>();
TreeMap<LocalDateTime, UR_State> sim_states = new TreeMap<>();
LocalDateTime analysis_time = LocalDateTime.MIN;
Event tcp_pos_error_event = new Event();
Event tcp_rot_error_event = new Event();
Event[] joint_error_events = new Event[6];
{
  for (int i = 0; i < joint_error_events.length; i++) {
    joint_error_events[i] = new Event();
  }
}

class TemporalData {
  final int capacity;

  List<LocalDateTime> times = new LinkedList<>();
  List<Double> q1_errs = new LinkedList<>();
  List<Double> q2_errs = new LinkedList<>();
  List<Double> q3_errs = new LinkedList<>();
  List<Double> q4_errs = new LinkedList<>();
  List<Double> q5_errs = new LinkedList<>();
  List<Double> q6_errs = new LinkedList<>();
  List<Double> tcp_dist_errs = new LinkedList<>();
  List<Double> tcp_angle_errs = new LinkedList<>();
  List<Double> gripper_angle_errs = new LinkedList<>();

  TemporalData(int capacity) {
    this.capacity = capacity;
  }

  public void push(LocalDateTime time, UR_State real, UR_State sim, double tcp_dist_err, double tcp_angle_err, double gripper_angle_err) {
    while (times.size() >= capacity) {
      pop();
    }
    times.add(time);
    q1_errs.add(Math.abs(real.q[0] - sim.q[0]));
    q2_errs.add(Math.abs(real.q[1] - sim.q[1]));
    q3_errs.add(Math.abs(real.q[2] - sim.q[2]));
    q4_errs.add(Math.abs(real.q[3] - sim.q[3]));
    q5_errs.add(Math.abs(real.q[4] - sim.q[4]));
    q6_errs.add(Math.abs(real.q[5] - sim.q[5]));
    tcp_dist_errs.add(tcp_dist_err);
    tcp_angle_errs.add(tcp_angle_err);
    gripper_angle_errs.add(gripper_angle_err);
  }

  public void pop() {
    if (times.size() == 0) return;
    times.remove(0);
    q1_errs.remove(0);
    q2_errs.remove(0);
    q3_errs.remove(0);
    q4_errs.remove(0);
    q5_errs.remove(0);
    q6_errs.remove(0);
    tcp_dist_errs.remove(0);
    tcp_angle_errs.remove(0);
    gripper_angle_errs.remove(0);
  }
}

TemporalData timedata;

public int getIndexAfterTime(List<LocalDateTime> times, LocalDateTime target) {
  int i = 0;
  for (LocalDateTime t : times) {
    if (target.compareTo(t) <= 0) {
      break;
    }
    i++;
  }
  return i;
}

public void detectErrorOverThresholdForTime(List<LocalDateTime> times, List<Double> data, double threshold, double duration, Event errorEvent) {
  LocalDateTime backwardsInTime = analysis_time.minusNanos((long) (1e9f*duration));
  int startIndex = getIndexAfterTime(times, backwardsInTime);
  int endIndex = times.size();
  int dataLength = endIndex-startIndex;
  LocalDateTime dataStartTime = times.get(startIndex);
  // Make sure that we aren't measuring for too short of a duration to be statistically significant
  float secondsBetweenStartAndTargetTime = 1000f * Math.abs(toEpochMillis(backwardsInTime) - toEpochMillis(dataStartTime));
  if (startIndex < endIndex) {
    double err = 0.0f;
    if (secondsBetweenStartAndTargetTime < 0.05f*duration) {
      ArrayList<Double> temporal_error = new ArrayList<>(dataLength);
      Iterator<Double> err_iter = data.iterator();
      for (int i = 0; i < startIndex; i++) err_iter.next();
      err_iter.forEachRemaining((val) -> {
        temporal_error.add(val);
      }
      );
      err = median(temporal_error);
    }
    if (err > Math.abs(threshold)) {
      errorEvent.call();
    }
  }
}

public void analyzeData() {
  while (true) {
    UR_State real = null, sim = null;
    if (!(real_states.isEmpty() || sim_states.isEmpty())) {
      Map.Entry<LocalDateTime, UR_State> real_first = real_states.firstEntry();
      Map.Entry<LocalDateTime, UR_State> sim_first = sim_states.firstEntry();
      real = real_first.getValue();
      sim = sim_first.getValue();
      // Convert time to millisecond precision to better detect overlapping timesteps
      LocalDateTime real_time = fromEpochMillis(toEpochMillis(real_first.getKey()));
      LocalDateTime sim_time = fromEpochMillis(toEpochMillis(sim_first.getKey()));
      analysis_time = min(real_time, sim_time);
      if (analysis_time.compareTo(real_time) >= 0) {
        synchronized(real_states) {
          real_states.remove(real_first.getKey());
        }
      }
      if (analysis_time.compareTo(sim_time) >= 0) {
        synchronized(sim_states) {
          sim_states.remove(sim_first.getKey());
        }
      }
    }
    if (real == null || sim == null) {
      break;
    }
    PVector real_tcp = new PVector((float) real.tcp_x, (float)  real.tcp_y, (float)  real.tcp_z);
    PVector sim_tcp = new PVector((float) sim.tcp_x, (float)  sim.tcp_y, (float)  sim.tcp_z);
    double dist = PVector.dist(real_tcp, sim_tcp);
    double angle = quat_angle_between(real.tcp_rot, sim.tcp_rot);
    //println(angle);
    //double[] real_aa = quat_to_axis_angle(real.tcp_rot);
    //double[] sim_aa = quat_to_axis_angle(sim.tcp_rot);
    //println(String.format("Real axis-angle: %.2f, %.2f, %.2f; %.2f | Sim axis-angle: %.2f, %.2f, %.2f; %.2f", real_aa[0], real_aa[1], real_aa[2], real_aa[3], sim_aa[0], sim_aa[1], sim_aa[2], sim_aa[3]));
    double g_angle = Math.abs(real.gq - sim.gq);
    analysis.clear();
    analysis.add(dist);
    analysis.add(angle);
    for (int i = 0; i < real.t.length; i++) {
      analysis.add(Math.abs(real.t[i] - sim.t[i]));
    }
    analysis.add(g_angle);

    timedata.push(analysis_time, real, sim, dist, angle, g_angle);

    detectErrorOverThresholdForTime(timedata.times, timedata.tcp_dist_errs, TCP_POS_ERROR_THRESHOLD, TCP_POS_ERROR_DURATION, tcp_pos_error_event);
    detectErrorOverThresholdForTime(timedata.times, timedata.tcp_angle_errs, TCP_ROT_ERROR_THRESHOLD, TCP_ROT_ERROR_DURATION, tcp_rot_error_event);
    detectErrorOverThresholdForTime(timedata.times, timedata.q1_errs, JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, joint_error_events[0]);
    detectErrorOverThresholdForTime(timedata.times, timedata.q2_errs, JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, joint_error_events[1]);
    detectErrorOverThresholdForTime(timedata.times, timedata.q3_errs, JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, joint_error_events[2]);
    detectErrorOverThresholdForTime(timedata.times, timedata.q4_errs, JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, joint_error_events[3]);
    detectErrorOverThresholdForTime(timedata.times, timedata.q5_errs, JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, joint_error_events[4]);
    detectErrorOverThresholdForTime(timedata.times, timedata.q6_errs, JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, joint_error_events[5]);

    if (dataTable != null) {
      synchronized(dataTable) {
        writeDataRow(dataTable, analysis_time, real, sim, analysis);
      }
    }
  } // while(true)
}

class ErrorReporter implements Runnable {
  private float threshold, duration, cooldown = 0;
  private String error_name, units;
  public final Queue<String> errors;
  public ErrorReporter(String errname, float thresh, float duration, String units) {
    error_name = errname;
    threshold = thresh;
    this.duration = duration;
    this.units = units;
    errors = new LinkedList<String>();
  }
  public void cooldown(float dt) {
    cooldown -= dt;
  }
  public void run() {
    if (cooldown <= 0) {
      cooldown = duration;
      StringBuilder sb = new StringBuilder();
      sb.append(analysis_time);
      sb.append(": ");
      sb.append(error_name);
      sb.append(" median has been over ");
      sb.append(threshold);
      sb.append(" ");
      sb.append(units);
      sb.append(" for ");
      sb.append(duration);
      sb.append(" seconds.");
      errors.offer(sb.toString());
    }
  }
}

public Table createDataTable() {
  Table t = new Table();
  t.addColumn("time", Table.STRING);
  t.addColumn("q1", Table.DOUBLE);
  t.addColumn("q2", Table.DOUBLE);
  t.addColumn("q3", Table.DOUBLE);
  t.addColumn("q4", Table.DOUBLE);
  t.addColumn("q5", Table.DOUBLE);
  t.addColumn("q6", Table.DOUBLE);
  t.addColumn("w1", Table.DOUBLE);
  t.addColumn("w2", Table.DOUBLE);
  t.addColumn("w3", Table.DOUBLE);
  t.addColumn("w4", Table.DOUBLE);
  t.addColumn("w5", Table.DOUBLE);
  t.addColumn("w6", Table.DOUBLE);
  t.addColumn("a1", Table.DOUBLE);
  t.addColumn("a2", Table.DOUBLE);
  t.addColumn("a3", Table.DOUBLE);
  t.addColumn("a4", Table.DOUBLE);
  t.addColumn("a5", Table.DOUBLE);
  t.addColumn("a6", Table.DOUBLE);
  t.addColumn("t1", Table.DOUBLE);
  t.addColumn("t2", Table.DOUBLE);
  t.addColumn("t3", Table.DOUBLE);
  t.addColumn("t4", Table.DOUBLE);
  t.addColumn("t5", Table.DOUBLE);
  t.addColumn("t6", Table.DOUBLE);
  t.addColumn("gq", Table.DOUBLE);
  t.addColumn("tcp_x", Table.DOUBLE);
  t.addColumn("tcp_y", Table.DOUBLE);
  t.addColumn("tcp_z", Table.DOUBLE);
  t.addColumn("tcp_rot_x", Table.DOUBLE);
  t.addColumn("tcp_rot_y", Table.DOUBLE);
  t.addColumn("tcp_rot_z", Table.DOUBLE);
  t.addColumn("tcp_rot_w", Table.DOUBLE);
  t.addColumn("s_q1", Table.DOUBLE);
  t.addColumn("s_q2", Table.DOUBLE);
  t.addColumn("s_q3", Table.DOUBLE);
  t.addColumn("s_q4", Table.DOUBLE);
  t.addColumn("s_q5", Table.DOUBLE);
  t.addColumn("s_q6", Table.DOUBLE);
  t.addColumn("s_w1", Table.DOUBLE);
  t.addColumn("s_w2", Table.DOUBLE);
  t.addColumn("s_w3", Table.DOUBLE);
  t.addColumn("s_w4", Table.DOUBLE);
  t.addColumn("s_w5", Table.DOUBLE);
  t.addColumn("s_w6", Table.DOUBLE);
  t.addColumn("s_a1", Table.DOUBLE);
  t.addColumn("s_a2", Table.DOUBLE);
  t.addColumn("s_a3", Table.DOUBLE);
  t.addColumn("s_a4", Table.DOUBLE);
  t.addColumn("s_a5", Table.DOUBLE);
  t.addColumn("s_a6", Table.DOUBLE);
  t.addColumn("s_t1", Table.DOUBLE);
  t.addColumn("s_t2", Table.DOUBLE);
  t.addColumn("s_t3", Table.DOUBLE);
  t.addColumn("s_t4", Table.DOUBLE);
  t.addColumn("s_t5", Table.DOUBLE);
  t.addColumn("s_t6", Table.DOUBLE);
  t.addColumn("s_gq", Table.DOUBLE);
  t.addColumn("s_tcp_x", Table.DOUBLE);
  t.addColumn("s_tcp_y", Table.DOUBLE);
  t.addColumn("s_tcp_z", Table.DOUBLE);
  t.addColumn("s_tcp_rot_x", Table.DOUBLE);
  t.addColumn("s_tcp_rot_y", Table.DOUBLE);
  t.addColumn("s_tcp_rot_z", Table.DOUBLE);
  t.addColumn("s_tcp_rot_w", Table.DOUBLE);
  t.addColumn("tcp_dist_err", Table.DOUBLE);
  t.addColumn("tcp_angle_err", Table.DOUBLE);
  t.addColumn("t1_err", Table.DOUBLE);
  t.addColumn("t2_err", Table.DOUBLE);
  t.addColumn("t3_err", Table.DOUBLE);
  t.addColumn("t4_err", Table.DOUBLE);
  t.addColumn("t5_err", Table.DOUBLE);
  t.addColumn("t6_err", Table.DOUBLE);
  return t;
}

public void writeDataRow(Table t, LocalDateTime timestamp, UR_State real, UR_State sim, ArrayList<Double> analysis) {
  TableRow r = t.addRow();
  r.setString("time", timestamp.toString());
  for (int i = 0; i < real.q.length; i++) {
    r.setDouble("q" + (i+1), real.q[i]);
  }
  for (int i = 0; i < real.w.length; i++) {
    r.setDouble("w" + (i+1), real.w[i]);
  }
  for (int i = 0; i < real.a.length; i++) {
    r.setDouble("a" + (i+1), real.a[i]);
  }
  for (int i = 0; i < real.t.length; i++) {
    r.setDouble("t" + (i+1), real.t[i]);
  }
  r.setDouble("gq", real.gq);
  r.setDouble("tcp_x", real.tcp_x);
  r.setDouble("tcp_y", real.tcp_y);
  r.setDouble("tcp_z", real.tcp_z);
  r.setDouble("tcp_rot_x", real.tcp_rot[0]);
  r.setDouble("tcp_rot_y", real.tcp_rot[1]);
  r.setDouble("tcp_rot_z", real.tcp_rot[2]);
  r.setDouble("tcp_rot_w", real.tcp_rot[3]);

  for (int i = 0; i < sim.q.length; i++) {
    r.setDouble("s_q" + (i+1), sim.q[i]);
  }
  for (int i = 0; i < sim.w.length; i++) {
    r.setDouble("s_w" + (i+1), sim.w[i]);
  }
  for (int i = 0; i < sim.a.length; i++) {
    r.setDouble("s_a" + (i+1), sim.a[i]);
  }
  for (int i = 0; i < sim.t.length; i++) {
    r.setDouble("s_t" + (i+1), sim.t[i]);
  }
  r.setDouble("s_gq", sim.gq);
  r.setDouble("s_tcp_x", sim.tcp_x);
  r.setDouble("s_tcp_y", sim.tcp_y);
  r.setDouble("s_tcp_z", sim.tcp_z);
  r.setDouble("s_tcp_rot_x", sim.tcp_rot[0]);
  r.setDouble("s_tcp_rot_y", sim.tcp_rot[1]);
  r.setDouble("s_tcp_rot_z", sim.tcp_rot[2]);
  r.setDouble("s_tcp_rot_w", sim.tcp_rot[3]);

  r.setDouble("tcp_dist_err", analysis.get(0));
  r.setDouble("tcp_angle_err", analysis.get(1));
  for (int i = 0; i < 6; i++) {
    r.setDouble("t" + (i+1) + "_err", analysis.get(i+2));
  }
}
interface Button {
  boolean contains(float mx, float my);
  boolean isEnabled();
  void setEnabled(boolean e);
  void draw(PGraphics c);
  default void press(MouseEvent e) {}
  default void release(MouseEvent e) {}
  default void click(MouseEvent e) {}
}

interface TextEntry extends Button {
  void keyPress(int key);
  void keyRelease(int key);
  void keyType(int key);
  String getText();
}

public String enterText(String text, int keyTyped, boolean singleLine) {
  if (keyTyped == BACKSPACE || keyTyped == DELETE) {
    return text.length() > 0 ? text.substring(0, text.length() - 1) : text;
  }
  if (keyTyped == CODED || keyTyped < 32) return text;
  if (singleLine && keyTyped == '\n') return text;
  return text + (char) keyTyped;
}

// final for security reasons, this is meant to handle password input
public final int enterText(char[] text, int cursor, int keyTyped, boolean singleLine) {
  if (keyTyped == BACKSPACE) {
    if (cursor > 0) text[--cursor] = 0;
  }
  if (keyTyped == CODED || keyTyped < 32) return cursor;
  if (singleLine && keyTyped == '\n') return cursor;
  if (cursor < text.length) text[cursor++] = (char) keyTyped;
  return cursor;
}

public int enterInteger(int number, int keyTyped, boolean negatable) {
  if (keyTyped == BACKSPACE) {
    number /= 10;
  }
  if (negatable && keyTyped == '-') {
    number *= -1;
  }
  if (Character.isDigit(keyTyped)) {
    if (Integer.MAX_VALUE / 10 >= number) {
      number = number * 10 + Integer.parseInt(Character.toString((char) keyTyped));
    }
  }
  return number;
}
class Rect {
  public float x, y, w, h;
  public Rect() {
    this(0, 0, 0, 0);
  }
  public Rect(float x, float y, float w, float h) {
    set(x, y, w, h);
  }
  public Rect(Rect r) {
    this(r.x, r.y, r.w, r.h);
  }
  public void set(Rect r) {
    set(r.x, r.y, r.w, r.h);
  }
  public void set(float x, float y, float w, float h) {
    this.x = x; this.y = y; this.w = w; this.h = h;
  }
  public void draw(PGraphics c) {
    c.rect(x, y, w, h);
  }
  public boolean contains(float mx, float my) {
    return abs(mx - x) <= w*0.5f && abs(my - y) <= h*0.5f;
  }
  public boolean cornerContains(float mx, float my) {
    return mx > x && mx <= x + w && my > y && my <= y + h;
  }
  public String toString() {
    return x + ", " + y + ", " + w + ", " + h;
  }
}

class Align {
  PGraphics canvas;
  float ax, ay;
  int alignX, alignY;
  float ox, oy;
  float sw, sh;
  float mw, mh, Mw, Mh;
  Align() {
    alignX = CENTER;
    alignY = CENTER;
    mw = 10;
    mh = 10;
    Mw = Float.MAX_VALUE;
    Mh = Float.MAX_VALUE;
  }
  public Align copy(Align a) {
    canvas = a.canvas;
    ax = a.ax;
    ay = a.ay;
    alignX = a.alignX;
    alignY = a.alignY;
    ox = a.ox;
    oy = a.oy;
    sw = a.sw;
    sh = a.sh;
    mw = a.mw;
    mh = a.mh;
    Mw = a.Mw;
    Mh = a.Mh;
    return this;
  }
  public Align setBounds(PGraphics c) {
    canvas = c;
    return this;
  }
  public Align setAlign(int x, int y) {
    if (x == LEFT || x == CENTER || x == RIGHT)
      alignX = x;
    if (y == TOP || y == CENTER || y == BOTTOM)
      alignY = y;
    return this;
  }
  public Align setAnchor(float ax, float ay) {
    this.ax = ax;
    this.ay = ay;
    return this;
  }
  public Align setOffset(float ox, float oy) {
    this.ox = ox;
    this.oy = oy;
    return this;
  }
  public Align setScale(float sw, float sh) {
    this.sw = sw;
    this.sh = sh;
    return this;
  }
  public Align setMinSize(float w, float h) {
    this.mw = w;
    this.mh = h;
    return this;
  }
  public Align setMaxSize(float w, float h) {
    this.Mw = w;
    this.Mh = h;
    return this;
  }
  public float getX() {
    float w = canvas == null ? 0 : canvas.width;
    return w * ax + ox;
  }
  public float getY() {
    float h = canvas == null ? 0 : canvas.height;
    return h * ay + oy;
  }
  public float getW() {
    float w = canvas == null ? 0 : canvas.width;
    return constrain(w * sw, mw, Mw);
  }
  public float getH() {
    float h = canvas == null ? 0 : canvas.height;
    return constrain(h * sh, mh, Mh);
  }
  public Rect getCenterRect() {
    Rect r = new Rect(getX(), getY(), getW(), getH());
    switch(alignX) {
    case LEFT:
      r.x += r.w*0.5f;
      break;
    case RIGHT:
      r.x -= r.w*0.5f;
      break;
    }
    switch(alignY) {
    case TOP:
      r.y += r.h*0.5f;
      break;
    case BOTTOM:
      r.y -= r.h*0.5f;
      break;
    }
    return r;
  }
  public boolean contains(float mx, float my) {
    Rect r = getCenterRect();
    return r.contains(mx, my);//abs(mx - r.x) <= r.w*0.5 && abs(my - r.y) <= r.h*0.5;
  }
}

public class TextButton implements TextEntry {
  boolean enabled = true;
  public String text;
  public int textAlignX, textAlignY;
  public float minTextSize, maxTextSize, textScale;
  public int bgCol, textCol, outlineCol;
  public float outlineWeight;
  public Align align = new Align();
  public TextButton() {
    this("");
  }
  public TextButton(String text) {
    textAlignX = CENTER;
    textAlignY = CENTER;
    textScale = 0;
    minTextSize = 14;
    maxTextSize = 14;
    bgCol = color(255);
    textCol = color(0);
    outlineCol = color(0);
    outlineWeight = 1;
    this.text = (text == null ? "" : text);
  }
  public boolean contains(float mx, float my) {
    return align.contains(mx, my);
  }
  public boolean isEnabled() {
    return enabled;
  }
  public void setEnabled(boolean e) {
    enabled = e;
  }
  public void draw(PGraphics c) {
    align.setBounds(c);
    c.pushStyle();
    c.rectMode(CENTER);
    Rect r = align.getCenterRect(); 
    c.strokeWeight(outlineWeight);
    c.stroke(outlineCol);
    c.fill(bgCol);
    r.draw(c);
    c.fill(textCol);
    c.textSize(getTextSize());
    c.textAlign(textAlignX, textAlignY);
    if (text != null)
      c.text(text, r.x, r.y, r.w, r.h);
    c.popStyle();
  }
  public void press(MouseEvent e) {
  }
  public void release(MouseEvent e) {
  }
  public void click(MouseEvent e) {
  }
  public void keyPress(int key) {
    if (key == CODED) return;
    text = enterText(text, key, true);
  }
  public void keyRelease(int key) {
  }
  public void keyType(int key) {
  }
  public TextButton setTextAlign(int x, int y) {
    if (x == LEFT || x == CENTER || x == RIGHT)
      textAlignX = x;
    if (y == TOP || y == CENTER || y == BOTTOM)
      textAlignY = y;
    return this;
  }
  public void setTextSize(float size) {
    minTextSize = size;
    maxTextSize = size;
  }
  public float getTextSize() {
    return constrain(align.getH() * textScale, minTextSize, maxTextSize);
  }
  public String getText() {
    return text;
  }
}

public class IntButton extends TextButton {
  int value;
  boolean negatable;
  public IntButton() {
    this(0);
  }
  public IntButton(int val) {
    super();
    value = val;
  }
  @Override public 
    void draw(PGraphics c) {
    text = getText();
    super.draw(c);
  }
  @Override public 
    void keyPress(int key) {
    if (key == CODED) return;
    value = enterInteger(value, key, negatable);
  }
  @Override public 
    String getText() {
    return String.valueOf(value);
  }
  public int getValue() {
    return value;
  }
}

public class CheckBox implements Button {
  public int bgCol, trueCol, falseCol, outlineCol;
  public float outlineWeight;
  public boolean value, enabled = true;
  public Align align = new Align();
  public CheckBox(boolean val) {
    value = val;
    bgCol = color(255);
    trueCol = color(0, 255, 0);
    falseCol = color(255, 0, 0);
    outlineCol = color(0);
    outlineWeight = 2;
  }
  public CheckBox() {
    this(false);
  }
  public boolean isEnabled() { 
    return enabled;
  }
  public void setEnabled(boolean e) { 
    enabled = e;
  }
  public void draw(PGraphics c) {
    align.setBounds(c);
    c.pushStyle();
    c.rectMode(CENTER);
    Rect r = align.getCenterRect();
    c.strokeWeight(outlineWeight);
    c.stroke(outlineCol);
    c.fill(bgCol);
    r.draw(c);
    c.fill(value ? trueCol : falseCol);
    c.textAlign(CENTER, CENTER);
    c.textSize(r.h * 0.8f);
    c.text(value ? "y" : "n", r.x, r.y);
    c.popStyle();
  }
  public boolean contains(float mx, float my) {
    return align.contains(mx, my);
  }
  public void press(MouseEvent e) {
  }
  public void release(MouseEvent e) {
  }
  public void click(MouseEvent e) {
    value = !value;
  }
}
class GraphInfo {
  float minX = 0, maxX = 10, stepX = 1;
  float minY = 0, maxY = 10, stepY = 1;
  String title = "";
  String xlabel = "x axis";
  String ylabel = "y axis";
  int minorTicks = 0;
  int xdecimals = 0, ydecimals = 0;
  boolean showGrid = true;
  
  GraphInfo() {
  }
  
  GraphInfo(GraphInfo gi) {
    minX = gi.minX;
    maxX = gi.maxX;
    stepX = gi.stepX;
    minY = gi.minY;
    maxY = gi.maxY;
    stepY = gi.stepY;
    title = gi.title;
    xlabel = gi.xlabel;
    ylabel = gi.ylabel;
    minorTicks = gi.minorTicks;
    xdecimals = gi.xdecimals;
    ydecimals = gi.ydecimals;
    showGrid = gi.showGrid;
  }

  public GraphInfo setTitle(String title) {
    this.title = title;
    return this;
  }

  public GraphInfo setAxisLimits(float minX, float maxX, float minY, float maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
    return this;
  }

  public GraphInfo setAxisStep(float stepX, float stepY) {
    this.stepX = stepX;
    this.stepY = stepY;
    return this;
  }

  public GraphInfo setAxisDecimals(int xdec, int ydec) {
    xdecimals = xdec;
    ydecimals = ydec;
    return this;
  }

  public GraphInfo setAxisLabels(String x, String y) {
    xlabel = x;
    ylabel = y;
    return this;
  }
  
  public GraphInfo setMinorTicks(int ticks) {
    minorTicks = ticks;
    return this;
  }
  
  public GraphInfo showGrid(boolean showit) {
    showGrid = showit;
    return this;
  }
}

public Rect draw_graph_body(PGraphics c, Rect bounds, GraphInfo info) {
  float axis_size = 30;
  float tick_size = 6;
  c.push();
  c.fill(0);
  // title
  c.textSize(14);
  c.textAlign(CENTER, TOP);
  c.text(info.title, bounds.x, bounds.y-bounds.h*0.5f);
  //c.textSize(12);
  // x axis
  c.textAlign(CENTER, BOTTOM);
  c.text(info.xlabel, bounds.x, bounds.y+bounds.h*0.5f + 3);
  c.strokeWeight(1);
  c.pushMatrix();
  c.translate(bounds.x-bounds.w*0.5f, bounds.y+bounds.h*0.5f);
  c.line(axis_size, -axis_size, bounds.w, -axis_size);
  c.textAlign(CENTER, TOP);
  for (float xval = info.minX; xval <= info.maxX; xval += info.stepX) {
    if (info.minorTicks > 0) {
      float minor_step = info.stepX/(info.minorTicks + 1);
      int minor_ticks_count = 0;
      for (float x_minor = xval+minor_step; minor_ticks_count < info.minorTicks && x_minor <= info.maxX; x_minor += minor_step) {
        float x = map(x_minor, info.minX, info.maxX, axis_size, bounds.w-axis_size);
        c.stroke(169);
        c.line(x, -axis_size, x, tick_size*0.5f-axis_size);
        if (info.showGrid) {
          c.line(x, -axis_size, x, axis_size-bounds.h);
        }
        minor_ticks_count++;
      }
    }
    float x = map(xval, info.minX, info.maxX, axis_size, bounds.w-axis_size);
    c.stroke(0);
    c.line(x, -axis_size, x, tick_size-axis_size);
    if (info.showGrid) {
      stroke(128);
      c.line(x, -axis_size, x, axis_size-bounds.h);
    }
    c.text(String.format("%."+info.xdecimals+"f", xval), x, 0.4f*tick_size-axis_size);
  }
  c.popMatrix();
  // y axis
  c.pushMatrix();
  c.translate(bounds.x-bounds.w*0.5f, bounds.y+bounds.h*0.5f);
  c.rotate(-HALF_PI);
  c.fill(0);
  c.textAlign(CENTER, TOP);
  c.text(info.ylabel, bounds.h*0.5f, 10-textWidth(String.format("%."+info.ydecimals+"f", 0.0f)));
  c.strokeWeight(1);
  c.line(axis_size, axis_size, bounds.h, axis_size);
  c.textAlign(CENTER, BOTTOM);
  for (float yval = info.minY; yval <= info.maxY; yval += info.stepY) {
    if (info.minorTicks > 0) {
      float minor_step = info.stepY/(info.minorTicks + 1);
      int minor_ticks_count = 0;
      for (float y_minor = yval+minor_step; minor_ticks_count < info.minorTicks && y_minor <= info.maxY; y_minor += minor_step) {
        float y = map(y_minor, info.minY, info.maxY, axis_size, bounds.h-axis_size);
        c.stroke(169);
        c.line(y, axis_size, y, axis_size-tick_size*0.75f);
        if (info.showGrid) {
          c.line(y, axis_size, y, bounds.w-axis_size);
        }
        minor_ticks_count++;
      }
    }
    float y = map(yval, info.minY, info.maxY, axis_size, bounds.h-axis_size);
    c.stroke(0);
    c.line(y, axis_size, y, axis_size-tick_size);
    if (info.showGrid) {
      stroke(128);
      c.line(y, axis_size, y, bounds.w-axis_size);
    }
    c.pushMatrix();
    c.translate(y, axis_size-0.4f*tick_size);
    c.rotate(HALF_PI);
    c.textAlign(RIGHT, BOTTOM);
    c.text(String.format("%."+info.ydecimals+"f", yval), 0, 0);
    c.popMatrix();
  }
  c.popMatrix();
  c.pop();
  Rect data_area = new Rect(bounds);
  data_area.w -= axis_size*2;
  data_area.h -= axis_size*2;
  return data_area;
}

public void draw_graph_data(PGraphics c, Rect bounds, GraphInfo info, List<Double> xdata, List<Double> ydata, int style, int col) {
  c.push();
  //c.clip(bounds.x-bounds.w*0.5, bounds.y-bounds.h*0.5, bounds.w, bounds.h);
  if (style == LINE) {
    //Integer[] sorted_indices = getSortedIndices(xdata);
    //List<Double> sorted_x_data = reorderedList(xdata, sorted_indices);
    //List<Double> sorted_y_data = reorderedList(ydata, sorted_indices);
    c.stroke(col);
    c.strokeWeight(3);
    c.strokeCap(ROUND);
    Float prevx = null, prevy = null;
    // Assume both have the same length, but if they don't just stop after the shortest finishes
    Iterator<Double> xiter = xdata.iterator();
    Iterator<Double> yiter = ydata.iterator();
    while (xiter.hasNext() && yiter.hasNext()) {
      double xval = xiter.next();
      double yval = yiter.next();
      float x = map((float) xval, info.minX, info.maxX, bounds.x-bounds.w*0.5f, bounds.x+bounds.w*0.5f);
      float y = map((float) yval, info.minY, info.maxY, bounds.y+bounds.h*0.5f, bounds.y-bounds.h*0.5f);
      boolean visible = true;
      if (prevx != null && prevy != null) {
        visible = dist(prevx, prevy, x, y) > 1;
        if (bounds.contains(prevx, prevy) && bounds.contains(x, y) && (visible || !xiter.hasNext() || !yiter.hasNext())) {
          c.line(prevx, prevy, x, y);
        }
      }
      if (visible) {
        prevx = x;
        prevy = y;
      }
    }
  } else { // points
    c.stroke(col);
    c.strokeWeight(5);
    c.strokeCap(ROUND);
    Iterator<Double> xiter = xdata.iterator();
    Iterator<Double> yiter = ydata.iterator();
    while (xiter.hasNext() && yiter.hasNext()) {
      double xval = xiter.next();
      double yval = yiter.next();
      float x = map((float) xval, info.minX, info.maxX, bounds.x-bounds.w*0.5f, bounds.x+bounds.w*0.5f);
      float y = map((float) yval, info.minY, info.maxY, bounds.y+bounds.h*0.5f, bounds.y-bounds.h*0.5f);
      if (bounds.contains(x,y)) {
        c.point(x, y);
      }
    }
  }
  //c.noClip();
  c.pop();
}

public void draw_graph(PGraphics c, Rect bounds, GraphInfo info, List<Double> xdata, List<Double> ydata, int style, int col) {
  Rect r = draw_graph_body(c, bounds, info);
  draw_graph_data(c, r, info, xdata, ydata, style, col);
}

public void draw_graph_legend(PGraphics c, String[] axisNames, int[] colors) {
  final float lineheight = 15;
  c.push();
  c.textSize(14);
  float totalheight = lineheight*axisNames.length;
  float maxwidth = 0;
  for(String s : axisNames) {
    maxwidth = max(maxwidth, c.textWidth(s));
  }
  c.rectMode(CORNER);
  c.fill(255);
  c.stroke(1);
  c.strokeWeight(2);
  c.rect(0, 0, maxwidth+25, totalheight+10);
  c.translate(5, 5);
  c.textAlign(LEFT, TOP);
  c.noStroke();
  for(int i = 0; i < axisNames.length; i++) {
    String name = axisNames[i];
    int col = colors[i];
    c.fill(col);
    c.text(name, 0, 0);
    c.circle(maxwidth+10, lineheight*0.5f, 15);
    c.translate(0, lineheight);
  }
  
  
  c.pop();
}
// UI
String[] views = {"Incoming Data", "Real State", "Sim State", "Analysis"};
int view = 0;

Mode infodump = new Mode() {
  public void draw() {
    ArrayList<String> lines = new ArrayList<>();
    String viewtitles = "Press number to view: ";
    for (int i = 0; i < views.length; i++) {
      viewtitles += (i+1) + ". " + views[i];
      if (i < views.length - 1) viewtitles += ", ";
    }
    lines.add(viewtitles);
    lines.add("Local server IP: " + Server.ip());
    lines.add(String.format("Send rate: %.1f Hz, Time scale: %.2f", frameRate, timeScale));
    lines.add(playing ? "Playing" : "Paused");
    lines.add(String.format("Playback time: %s", playback.time.toString()));
    if (view == 0) {
      lines.add("Sync Data (id [index]: value):");
      SampleSequence[] seqs = playback.getCurrentSequences();
      for (int i = 0; i < playback.state.length; i++) {
        int time_i = playback.time_array_indices[i];
        double d = playback.state[i];
        String dataItemId = "unknown";
        if (seqs != null) {
          dataItemId = seqs[i].dataItemId;
        }
        lines.add(String.format("%s [%d]: %.2f", dataItemId, time_i, d));
      }
      lines.add("Queue size: " + playback.queue.size());
    } else if (view == 1) {
      lines.add("");
      //lines.add("Joint positions:");
      for (int i = 0; i < realstate.q.length; i++) {
        lines.add("q" + (i+1) + ": " + realstate.q[i]);
      }
      //lines.add("Joint velocities:");
      for (int i = 0; i < realstate.w.length; i++) {
        lines.add("w" + (i+1) + ": " + realstate.w[i]);
      }
      //lines.add("Joint accelerations:");
      for (int i = 0; i < realstate.a.length; i++) {
        lines.add("a" + (i+1) + ": " + realstate.a[i]);
      }
      //lines.add("Joint torques:");
      for (int i = 0; i < simstate.t.length; i++) {
        lines.add("t" + (i+1) + ": " + realstate.t[i]);
      }
      lines.add("Gripper servo: " + realstate.gq);
      lines.add("TCP x: " + realstate.tcp_x);
      lines.add("TCP y: " + realstate.tcp_y);
      lines.add("TCP z: " + realstate.tcp_z);
      lines.add("TCP rot qx: " + realstate.tcp_rot[0]);
      lines.add("TCP rot qy: " + realstate.tcp_rot[1]);
      lines.add("TCP rot qz: " + realstate.tcp_rot[2]);
      lines.add("TCP rot qw: " + realstate.tcp_rot[3]);
      //lines.add("TCP rot mag: " + quat_mag(realstate.tcp_rot));
    } else if (view == 2) {
      lines.add("Sim Timestamp: " + ur_sim_time);
      //lines.add("Joint positions:");
      for (int i = 0; i < simstate.q.length; i++) {
        lines.add("q" + (i+1) + ": " + simstate.q[i]);
      }
      //lines.add("Joint velocities:");
      for (int i = 0; i < simstate.w.length; i++) {
        lines.add("w" + (i+1) + ": " + simstate.w[i]);
      }
      //lines.add("Joint accelerations:");
      for (int i = 0; i < simstate.a.length; i++) {
        lines.add("a" + (i+1) + ": " + simstate.a[i]);
      }
      //lines.add("Joint torques:");
      for (int i = 0; i < simstate.t.length; i++) {
        lines.add("t" + (i+1) + ": " + simstate.t[i]);
      }
      lines.add("Gripper servo: " + simstate.gq);
      lines.add("TCP x: " + simstate.tcp_x);
      lines.add("TCP y: " + simstate.tcp_y);
      lines.add("TCP z: " + simstate.tcp_z);
      lines.add("TCP rot qx: " + simstate.tcp_rot[0]);
      lines.add("TCP rot qy: " + simstate.tcp_rot[1]);
      lines.add("TCP rot qz: " + simstate.tcp_rot[2]);
      lines.add("TCP rot qw: " + simstate.tcp_rot[3]);
      //lines.add("TCP rot mag: " + quat_mag(simstate.tcp_rot));
    } else if (view == 3) {
      lines.add("Sim Timestamp: " + ur_sim_time);
      lines.add("Analysis Timestamp: " + analysis_time);
      if (analysis.size() == 0) {
        lines.add("No data yet");
      } else {
        lines.add("TCP distance error: " + analysis.get(0));
        lines.add("TCP angle error: " + analysis.get(1)*180.0f/Math.PI);
        lines.add("Gripper servo error: " + analysis.get(2)*180.0f/Math.PI);
        for (int i = 0; i < 6; i++) {
          lines.add("t" + (i+1) + " err: " + analysis.get(i+3));
        }
      }
    }


    fill(255);
    float ly = 0;
    for (String s : lines) {
      text(s, 0, ly);
      ly += 15;
    }
    ly = 0;
  }
  
  public void mouseEvent(MouseEvent e) {
    if(e.getAction() == MouseEvent.WHEEL) {
      stepTimeScale(-(e.isControlDown() ? e.getCount() : e.getCount()*10));
    }
    if(e.getAction() == MouseEvent.PRESS) {
      if (e.getButton() == CENTER) {
        timeScale = 1.0f;
      }
    }
  }

  public void keyPressed() {
    if (keyCode == UP) {
      stepTimeScale(1);
    }
    if (keyCode == DOWN) {
      stepTimeScale(-1);
    }
    if (key >= '1' && key <= '9') {
      int newview = Integer.parseInt(""+key)-1;
      if (newview >= 0 && newview < views.length) view = newview;
    }
  }
};
// A data structure for MTConnect samples which maintains timestamp data but discards sequence indices.
class SampleSequence {
  String sampleType, dataItemId;
  SortedMap<LocalDateTime, Double> data;

  SampleSequence() {
    data = new TreeMap<>();
  }

  SampleSequence(String sampleType, String dataItemId) {
    this();
    this.sampleType = sampleType;
    this.dataItemId = dataItemId;
  }

  SampleSequence(XML samplesXML, String sampleType, String dataItemId) {
    this(sampleType, dataItemId);
    if (samplesXML != null && sampleType != null && dataItemId != null) {
      XML[] xdata = samplesXML.getChildren(sampleType);
      for (XML x : xdata) {
        if (dataItemId.equals(x.getString("dataItemId"))) {
          LocalDateTime ldt = parseUTC(x.getString("timestamp"));
          Double d = Double.parseDouble(x.getContent());
          data.put(ldt, d);
        }
      }
    }
  }
}

// Constructs three SampleSequences for 3D sample data, such as cartesian position or velocity.
public SampleSequence[] flatten3DSampleSequence(XML samplesXML, String sampleType, String dataItemId) {
  if (samplesXML == null || sampleType ==  null || dataItemId == null) return null;
  SampleSequence[] seqs = {
    new SampleSequence(sampleType+"_x", dataItemId+"_x"),
    new SampleSequence(sampleType+"_y", dataItemId+"_y"),
    new SampleSequence(sampleType+"_z", dataItemId+"_z"),
  };
  XML[] xdata = samplesXML.getChildren(sampleType);
  for (XML x : xdata) {
    if (dataItemId.equals(x.getString("dataItemId"))) {
      LocalDateTime ldt = parseUTC(x.getString("timestamp"));
      String[] tokens = splitTokens(x.getContent());
      for (int i = 0; i < seqs.length && i < tokens.length; i++) {
        Double d = Double.parseDouble(tokens[i]);
        seqs[i].data.put(ldt, d);
      }
    }
  }
  return seqs;
}

public LocalDateTime getEarliestTime(SampleSequence[] samples) {
  LocalDateTime earliest = LocalDateTime.MAX;
  for (SampleSequence s : samples) {
    if (s.data.isEmpty()) continue;
    LocalDateTime contender = s.data.firstKey();
    if (earliest.compareTo(contender) > 0) {
      earliest = contender;
    }
  }
  return earliest;
}

class SamplePlayback {
  private LocalDateTime time;
  private double[] state;
  private Queue<SampleSequence[]> queue;
  private LocalDateTime[][] time_arrays;
  private int[] time_array_indices;

  SamplePlayback(int numVals, LocalDateTime startTime) {
    state = new double[numVals];
    time_array_indices = new int[numVals];
    time = startTime;
    queue = new LinkedList<SampleSequence[]>();
  }

  SamplePlayback(int numVals) {
    this(numVals, LocalDateTime.MIN);
  }

  public int getValueCount() {
    return state.length;
  }

  public SamplePlayback enqueue(SampleSequence[] seq) {
    if (seq == null) {
      return this;
    }
    if (seq.length != getValueCount()) {
      throw new RuntimeException(String.format(
        "Sample sequence array (length %d) provided contains %s values for this playback (state length %d)",
        seq.length, seq.length > getValueCount() ? "too many" : "too few", getValueCount()
        ));
    }
    //if (time == LocalDateTime.MIN) {
    //  time = getEarliestTime(seq);
    //}
    queue.offer(seq);
    return this;
  }

  public void clear() {
    queue.clear();
    time_arrays = null;
  }

  private SampleSequence[] getCurrentSequences() {
    if (queue.isEmpty()) return null;
    return queue.peek();
  }

  private LocalDateTime[][] getCurrentTimes() {
    if (time_arrays == null && !queue.isEmpty()) {
      int count = getValueCount();
      time_arrays = new LocalDateTime[count][];
      SampleSequence[] sequences = getCurrentSequences();
      if (sequences == null) return null;
      for (int i = 0; i < count; i++) {
        // sequences are guaranteed to have the same length as count
        SampleSequence seq = sequences[i];
        Set<LocalDateTime> set = seq.data.keySet();
        time_arrays[i] = new LocalDateTime[set.size()];
        set.toArray(time_arrays[i]);
        time_array_indices[i] = 0;
      }
    }
    return time_arrays;
  }

  public SamplePlayback step(double timestep_seconds) {
    if (timestep_seconds < 0.0f) throw new IllegalArgumentException("Timestep cannot be negative, only step playback forward.");

    SampleSequence[] sequences = getCurrentSequences();
    if (sequences != null && time == LocalDateTime.MIN) {
      time = getEarliestTime(sequences);
      time_arrays = null;
    }
    LocalDateTime[][] times = getCurrentTimes();
    if (sequences == null || times == null) return this; // there is no more data, so don't bother updating anything
    time = time.plusNanos((long) (timestep_seconds*1e9f));
    int sequences_at_end = 0;
    for (int i = 0; i < times.length; i++) {
      int time_i = time_array_indices[i];
      // only try to iterate through time if the current sample timestamp is at or behind the current time
      if (time.compareTo(time_arrays[i][time_i]) >= 0) {
        // Step through the time arrays until the current time array timestamp is before the current time
        for (; time_i < time_arrays[i].length; time_i++) {
          boolean at_end = time_i >= time_arrays[i].length-1;
          if (at_end) {
            break;
          }
          if (time.compareTo(time_arrays[i][time_i]) >= 0 && time.compareTo(time_arrays[i][time_i+1]) < 0) {
            break;
          }
        }
      }
      if (time_arrays[i].length == 0 || time.compareTo(time_arrays[i][time_arrays[i].length - 1]) > 0) {
        sequences_at_end += 1;
      }
      // at this point, time_i should refer to the most recent data point
      SampleSequence seq = sequences[i];
      if (seq.data.isEmpty() || time_arrays[i].length == 0) {
        // no data
        //state[i] = 0;
      } else {
        time_array_indices[i] = time_i; // apply changes to the time index
        LocalDateTime data_time = time_arrays[i][time_i];
        Double datum = seq.data.get(data_time);
        state[i] = datum;
      }
    }
    if (sequences_at_end == times.length) {
      // then there is no more data in this sequence, so poll from the queue.
      queue.poll();
      time_arrays = null;
      Arrays.fill(time_array_indices, 0);
    }
    return this;
  }

  public double[] getState() {
    double[] copy = new double[state.length];
    System.arraycopy(state, 0, copy, 0, state.length);
    return copy;
  }
}
final int PRIMARY_COL = color(220, 220, 255);
final int Q_COL = color(80, 208, 242);
final int W_COL = color(4, 216, 4);
final int A_COL = color(255, 255, 75);
final int T_COL = color(255, 169, 30);
final int GRIP_COL = color(200, 50, 50);
PImage ur5e_img;
boolean show_values = false;
boolean stats_mode = false;
Mode menu = new Mode() {
  UR_State ur_real_display_state, ur_sim_display_state;

  ModeGUI ui = new ModeGUI();

  int joint_value_type = 0; // 0 = q, 1 = w, 2 = a, 3 = t

  TextButton general_mode_button, stats_mode_button;
  TextButton info_label;
  Button real_display, sim_display, stats_display;
  Button graph_display;
  TextButton q_button, w_button, a_button, t_button;
  TextButton real_time_label, sim_time_label;
  TextButton show_values_button, play_button, reset_time_button;
  TextButton events_label;
  ArrayList<String> events = new ArrayList<>();
  int events_scroll = 0;
  ArrayList<ErrorReporter> reporters = new ArrayList<>();

  public void setup() {
    ur5e_img = loadImage("UR5e.png");
    general_mode_button = new TextButton("General Info") {
      {
        align.setAnchor(0.25f, 0).setAlign(CENTER, TOP).setScale(0.5f, 0).setMinSize(0, 25);
      }
      public void press(MouseEvent e) {
        stats_mode = false;
      }
      public void draw(PGraphics c) {
        bgCol = stats_mode ? PRIMARY_COL : color(255);
        outlineCol = stats_mode ? color(0) : color(255, 0);
        super.draw(c);
      }
    };
    stats_mode_button = new TextButton("Statistics") {
      {
        align.setAnchor(0.75f, 0).setAlign(CENTER, TOP).setScale(0.5f, 0).setMinSize(0, 25);
      }
      public void press(MouseEvent e) {
        stats_mode = true;
      }
      public void draw(PGraphics c) {
        bgCol = !stats_mode ? PRIMARY_COL : color(255);
        outlineCol = !stats_mode ? color(0) : color(255, 0);
        super.draw(c);
      }
    };
    info_label = new TextButton() {
      {
        setTextAlign(LEFT, CENTER);
        outlineCol = color(255, 0);
        align.setAnchor(0, 0).setAlign(LEFT, TOP).setOffset(0, 25).setScale(1, 0).setMinSize(0, 25);
      }
      public void draw(PGraphics c) {
        text = String.format("Server IP: %s, Timestamp: %s, Send rate: %.2f Hz, Data queue: %d", Server.ip(), analysis_time.toString(), frameRate, playback.queue.size());
        super.draw(c);
      }
    };

    real_display = new Button() {
      Rect r = new Rect();
      boolean enabled = true;
      public boolean contains(float mx, float my) {
        return r.contains(mx, my);
      }
      public boolean isEnabled() {
        return enabled;
      }
      public void setEnabled(boolean e) {
        enabled = e;
      }
      public void draw(PGraphics c) {
        r.x = 0;
        r.y = 50;
        r.w = c.width*0.5f;
        r.h = c.height - r.y - 125;
        pushStyle();
        fill(255);
        stroke(0);
        rectMode(CORNER);
        //r.draw(c);
        textAlign(LEFT, TOP);
        fill(0);
        textSize(14);
        text("Real Robot", r.x+2, r.y, r.w-4, r.h);
        popStyle();
        UR_State state = ur_real_display_state != null ? ur_real_display_state : realstate;
        Rect centered = new Rect(r);
        centered.x += r.w*0.5f;
        centered.y += r.h*0.5f;
        double[] states;
        double minval = -PI, maxval = PI;
        int col = Q_COL;
        switch(joint_value_type) {
        case 0:
          states = state.q;
          break;
        case 1:
          states = state.w;
          col = W_COL;
          break;
        case 2:
          states = state.a;
          col = A_COL;
          break;
        case 3:
          states = state.t;
          minval = -100;
          maxval = 100;
          col = T_COL;
          break;
        default:
          joint_value_type = 0;
          states = state.q;
        }
        display_ur_joint_states(c, ur5e_img, centered, states, minval, maxval, state.gq, col);
      }
      public void press(MouseEvent e) {
      }
      public void release(MouseEvent e) {
      }
      public void click(MouseEvent e) {
      }
    };
    sim_display = new Button() {
      Rect r = new Rect();
      boolean enabled = true;
      public boolean contains(float mx, float my) {
        return r.contains(mx, my);
      }
      public boolean isEnabled() {
        return enabled;
      }
      public void setEnabled(boolean e) {
        enabled = e;
      }
      public void draw(PGraphics c) {
        r.x = c.width*0.5f;
        r.y = 50;
        r.w = c.width*0.5f;
        r.h = c.height - r.y - 125;
        pushStyle();
        fill(255);
        stroke(0);
        rectMode(CORNER);
        //r.draw(c);
        textAlign(RIGHT, TOP);
        fill(0);
        textSize(14);
        text("Sim Robot", r.x+2, r.y, r.w-4, r.h);
        popStyle();
        UR_State state = ur_sim_display_state != null ? ur_sim_display_state : simstate;
        Rect centered = new Rect(r);
        centered.x += r.w*0.5f;
        centered.y += r.h*0.5f;
        double[] states;
        double minval = -PI, maxval = PI;
        int col = Q_COL;
        switch(joint_value_type) {
        case 0:
          states = state.q;
          break;
        case 1:
          states = state.w;
          col = W_COL;
          break;
        case 2:
          states = state.a;
          col = A_COL;
          break;
        case 3:
          states = state.t;
          minval = -100;
          maxval = 100;
          col = T_COL;
          break;
        default:
          joint_value_type = 0;
          states = state.q;
        }
        display_ur_joint_states(c, ur5e_img, centered, states, minval, maxval, state.gq, col);
      }
    };
    stats_display = new Button() {
      Rect r = new Rect();
      boolean enabled = true;
      public boolean contains(float mx, float my) {
        return r.contains(mx, my);
      }
      public boolean isEnabled() {
        return enabled;
      }
      public void setEnabled(boolean e) {
        enabled = e;
      }
      public void draw(PGraphics c) {
        r.x = 0;
        r.y = 50;
        r.w = c.width*0.5f;
        r.h = c.height - r.y - 125;
        pushStyle();
        fill(255);
        stroke(0);
        rectMode(CORNER);
        //r.draw(c);
        textAlign(LEFT, TOP);
        fill(0);
        textSize(14);
        text("Joint Position Error", r.x+2, r.y, r.w-4, r.h);
        popStyle();
        UR_State m_realstate = ur_real_display_state; // != null ? ur_real_display_state : realstate;
        UR_State m_simstate = ur_sim_display_state; // != null ? ur_sim_display_state : simstate;
        Rect centered = new Rect(r);
        centered.x += r.w*0.5f;
        centered.y += r.h*0.5f;
        double[] states = new double[6];
        double minval = 0, maxval = TAU;
        int col = color(200, 69, 200);
        for (int i = 0; i < states.length; i++) {
          states[i] = Math.abs(m_realstate.q[i] - m_simstate.q[i]);
        }
        double g_err = Math.abs(m_realstate.gq - m_simstate.gq);

        display_ur_joint_states(c, ur5e_img, centered, states, minval, maxval, g_err, col);
      }
    };
    graph_display = new Button() {
      Rect r = new Rect();
      boolean enabled = true;
      public boolean contains(float mx, float my) {
        return r.contains(mx, my);
      }
      public boolean isEnabled() {
        return enabled;
      }
      public void setEnabled(boolean e) {
        enabled = e;
      }
      public void draw(PGraphics c) {
        r.x = c.width*0.5f;
        r.y = 50;
        r.w = c.width*0.5f;
        r.h = c.height - r.y - 125;
        pushStyle();
        fill(255);
        stroke(0);
        rectMode(CORNER);
        //r.draw(c);
        textAlign(RIGHT, TOP);
        fill(0);
        textSize(14);
        text("Error graphs", r.x+2, r.y, r.w-4, r.h);
        popStyle();
        Rect centered = new Rect(r);
        centered.x += r.w*0.5f;
        centered.y += r.h*0.5f;
        Rect joint_err_graph_bounds = new Rect(r.x+r.w*0.5f, r.y+r.h*0.25f, r.w, r.h*0.5f);
        GraphInfo joint_err_graph_info = new GraphInfo().setTitle("Joint Error").setAxisLabels("Time Passed (s)", "Error (rad)")
          .setAxisLimits(-10, 0, -HALF_PI-0.001f, HALF_PI+0.001f).setAxisStep(1, PI/8.0f).setAxisDecimals(0, 2);
        Rect joint_err_graph_data_bounds = draw_graph_body(c, joint_err_graph_bounds, joint_err_graph_info);

        ArrayList<Double> times = new ArrayList<Double>(timedata.times.size());
        for (LocalDateTime dt : timedata.times) {
          long millisdiff = toEpochMillis(dt)-toEpochMillis(analysis_time);
          double seconds = millisdiff / 1000.0d;
          times.add(seconds);
        }
        String[] axisNames = {"q1", "q2", "q3", "q4", "q5", "q6", "qg"};
        int[] colors = {
          color(255, 0, 0),
          color(255, 128, 0),
          color(255, 255, 0),
          color(0, 255, 0),
          color(0, 0, 255),
          color(255, 0, 255),
          GRIP_COL,
        };
        draw_graph_data(c, joint_err_graph_data_bounds, joint_err_graph_info, times, timedata.q1_errs, LINE, colors[0]);
        draw_graph_data(c, joint_err_graph_data_bounds, joint_err_graph_info, times, timedata.q2_errs, LINE, colors[1]);
        draw_graph_data(c, joint_err_graph_data_bounds, joint_err_graph_info, times, timedata.q3_errs, LINE, colors[2]);
        draw_graph_data(c, joint_err_graph_data_bounds, joint_err_graph_info, times, timedata.q4_errs, LINE, colors[3]);
        draw_graph_data(c, joint_err_graph_data_bounds, joint_err_graph_info, times, timedata.q5_errs, LINE, colors[4]);
        draw_graph_data(c, joint_err_graph_data_bounds, joint_err_graph_info, times, timedata.q6_errs, LINE, colors[5]);
        draw_graph_data(c, joint_err_graph_data_bounds, joint_err_graph_info, times, timedata.gripper_angle_errs, LINE, colors[6]);
        pushMatrix();
        translate(joint_err_graph_bounds.x+joint_err_graph_bounds.w*0.5f-50, joint_err_graph_bounds.y-joint_err_graph_bounds.h*0.5f+25);
        draw_graph_legend(c, axisNames, colors);
        popMatrix();
        
        float max_tcp_dist_err = max((float) max(timedata.tcp_dist_errs), 0.01f);
        GraphInfo dist_err_info = new GraphInfo().setTitle("TCP Position Error").setAxisLabels("Time Passed (s)", "Error (m)")
          .setAxisLimits(-10, 0, 0, max_tcp_dist_err).setAxisStep(1, max_tcp_dist_err*0.1249f).setAxisDecimals(0, 3);
        Rect dist_err_bounds = new Rect(r.x+r.w*0.25f, r.y+r.h*0.75f, r.w*0.5f, r.h*0.5f);
        draw_graph(c, dist_err_bounds, dist_err_info, times, timedata.tcp_dist_errs, LINE, color(255, 0, 0));
        
        float max_tcp_angle_err = max((float) max(timedata.tcp_angle_errs), PI/32.0f);
        GraphInfo angle_err_info = new GraphInfo().setTitle("TCP Rotation Error").setAxisLabels("Time Passed (s)", "Error (rad)")
          .setAxisLimits(-10, 0, 0, max_tcp_angle_err).setAxisStep(1, max_tcp_angle_err*0.1249f).setAxisDecimals(0, 2);
        Rect angle_err_bounds = new Rect(r.x+r.w*0.75f, r.y+r.h*0.75f, r.w*0.5f, r.h*0.5f);
        draw_graph(c, angle_err_bounds, angle_err_info, times, timedata.tcp_angle_errs, LINE, color(0, 0, 255));
      }
    };
    real_time_label = new TextButton() {
      {
        setTextAlign(LEFT, CENTER);
        align.setAnchor(0.175f, 1).setOffset(0, -100).setAlign(CENTER, BOTTOM).setScale(0.35f, 0).setMinSize(0, 25);
      }
      public void draw(PGraphics c) {
        super.draw(c);
        Rect r = align.getCenterRect();
        pushStyle();
        fill(0);
        textAlign(textAlignX, textAlignY);
        text(" Latest: " + playback.time, r.x-r.w*0.5f, r.y);
        popStyle();
      }
    };
    show_values_button = new TextButton("Show/Hide Values") {
      {
        bgCol = PRIMARY_COL;
        align.setAnchor(0.4f, 1).setOffset(0, -100).setAlign(CENTER, BOTTOM).setScale(0.1f, 0).setMinSize(0, 25);
      }
      public void draw(PGraphics c) {
        text = show_values ? "Hide Values" : "Show Values";
        super.draw(c);
      }
      public void click(MouseEvent e) {
        if (e.getButton() == LEFT) {
          show_values = !show_values;
        }
      }
    };
    play_button = new TextButton() {
      {
        bgCol = PRIMARY_COL;
        align.setAnchor(0.5f, 1).setOffset(0, -100).setAlign(CENTER, BOTTOM).setScale(0.1f, 0).setMinSize(0, 25);
      }
      public void draw(PGraphics c) {
        text = playing ? "Pause" : "Play";
        super.draw(c);
      }
      public void click(MouseEvent e) {
        if (e.getButton() == LEFT) {
          playing = !playing;
        }
      }
    };
    reset_time_button = new TextButton("Clear Queue") {
      {
        bgCol = PRIMARY_COL;
        align.setAnchor(0.6f, 1).setOffset(0, -100).setAlign(CENTER, BOTTOM).setScale(0.1f, 0).setMinSize(0, 25);
      }
      public void click(MouseEvent e) {
        if (e.getButton() == LEFT) {
          playback.queue.clear();
          playback.time_arrays = null;
          playback.time = LocalDateTime.MIN;
        }
      }
    };
    sim_time_label = new TextButton() {
      {
        setTextAlign(LEFT, CENTER);
        align.setAnchor(0.825f, 1).setOffset(0, -100).setAlign(CENTER, BOTTOM).setScale(0.35f, 0).setMinSize(0, 25);
      }
      public void draw(PGraphics c) {
        super.draw(c);
        Rect r = align.getCenterRect();
        pushStyle();
        fill(0);
        textAlign(textAlignX, textAlignY);
        text(" Latest: " + ur_sim_time, r.x-r.w*0.5f, r.y);
        popStyle();
      }
    };

    events_label = new TextButton() {
      {
        setTextSize(14);
        setTextAlign(LEFT, TOP);
        align.setAnchor(0, 1).setAlign(LEFT, BOTTOM).setScale(1, 0).setMinSize(0, 100);
      }
      public void draw(PGraphics c) {
        Rect r = align.getCenterRect();
        if(events.size() > 0) {
        final float lineheight = 14;
        int lines = floor(r.h/lineheight);
        int startidx = events.size()-1 - events_scroll;
        int endidx = max(0, startidx - lines);
        StringBuilder sb = new StringBuilder();
        for (int i = startidx; i >= endidx; i--) {
          sb.append(" ");
          sb.append(events.get(i));
          sb.append('\n');
        }
        text = sb.toString();
        } else {
          text = ""; 
        }
        super.draw(c);
      }
    };
    q_button = new TextButton("q\n(rad)") {
      {
        bgCol = Q_COL;
        align.setAnchor(0.5f, 1).setOffset(-75, -125).setAlign(CENTER, BOTTOM).setMinSize(50, 50);
      }
      public void click(MouseEvent e) {
        if (e.getButton() == LEFT) {
          joint_value_type = 0;
        }
      }
    };
    w_button = new TextButton("w\n(rad/s)") {
      {
        bgCol = W_COL;
        align.setAnchor(0.5f, 1).setOffset(-25, -125).setAlign(CENTER, BOTTOM).setMinSize(50, 50);
      }
      public void click(MouseEvent e) {
        if (e.getButton() == LEFT) {
          joint_value_type = 1;
        }
      }
    };
    a_button = new TextButton("a\n(rad/s)") {
      {
        bgCol = A_COL;
        align.setAnchor(0.5f, 1).setOffset(25, -125).setAlign(CENTER, BOTTOM).setMinSize(50, 50);
      }
      public void click(MouseEvent e) {
        if (e.getButton() == LEFT) {
          joint_value_type = 2;
        }
      }
    };
    t_button = new TextButton("T\n(N-m)") {
      {
        bgCol = T_COL;
        align.setAnchor(0.5f, 1).setOffset(75, -125).setAlign(CENTER, BOTTOM).setMinSize(50, 50);
      }
      public void click(MouseEvent e) {
        if (e.getButton() == LEFT) {
          joint_value_type = 3;
        }
      }
    };

    ui.addButton(info_label);
    ui.addButton(real_display);
    ui.addButton(sim_display);
    ui.addButton(stats_display);
    ui.addButton(graph_display);
    ui.addButton(real_time_label);
    ui.addButton(show_values_button);
    ui.addButton(play_button);
    ui.addButton(reset_time_button);
    ui.addButton(sim_time_label);
    ui.addButton(events_label);
    ui.addButton(q_button);
    ui.addButton(w_button);
    ui.addButton(a_button);
    ui.addButton(t_button);

    ui.addButton(general_mode_button);
    ui.addButton(stats_mode_button);
    
    ErrorReporter er;
    
    er = new ErrorReporter("TCP position error", TCP_POS_ERROR_THRESHOLD, TCP_POS_ERROR_DURATION, "m");
    tcp_pos_error_event.add(er);
    reporters.add(er);
    er = new ErrorReporter("TCP rotation error", TCP_ROT_ERROR_THRESHOLD, TCP_ROT_ERROR_DURATION, "rad");
    tcp_rot_error_event.add(er);
    reporters.add(er);
    er = new ErrorReporter("joint 1 error", JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, "rad");
    joint_error_events[0].add(er);
    reporters.add(er);
    er = new ErrorReporter("joint 2 error", JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, "rad");
    joint_error_events[1].add(er);
    reporters.add(er);
    er = new ErrorReporter("joint 3 error", JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, "rad");
    joint_error_events[2].add(er);
    reporters.add(er);
    er = new ErrorReporter("joint 4 error", JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, "rad");
    joint_error_events[3].add(er);
    reporters.add(er);
    er = new ErrorReporter("joint 5 error", JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, "rad");
    joint_error_events[4].add(er);
    reporters.add(er);
    er = new ErrorReporter("joint 6 error", JOINT_ERROR_THRESHOLD, JOINT_ERROR_DURATION, "rad");
    joint_error_events[5].add(er);
    reporters.add(er);
  }


  public void draw() {
    timeScale = 1.0f;
    if (!(real_states.isEmpty() || sim_states.isEmpty())) {
      ur_real_display_state = real_states.firstEntry().getValue();
      ur_sim_display_state = sim_states.firstEntry().getValue();
    } else {
      ur_real_display_state = realstate;
      ur_sim_display_state = simstate;
    }

    real_display.setEnabled(!stats_mode);
    sim_display.setEnabled(!stats_mode);
    q_button.setEnabled(!stats_mode);
    w_button.setEnabled(!stats_mode);
    a_button.setEnabled(!stats_mode);
    t_button.setEnabled(!stats_mode);

    stats_display.setEnabled(stats_mode);
    graph_display.setEnabled(stats_mode);

    for(ErrorReporter er : reporters) {
      er.cooldown((float) deltaTime);
      while(!er.errors.isEmpty()) {
        events.add(er.errors.poll());
      }
    }
    
    events_scroll = constrain(events_scroll, 0, events.size()-1);

    background(255);
    
  }

  public void drawUI() {
    ui.draw(g);
  }
  public void keyPressed() {
    ui.keyPress(key);
    if (ui.focus == null) {
      if (keyCode == 'Q') {
        joint_value_type = 0;
      }
      if (keyCode == 'W') {
        joint_value_type = 1;
      }
      if (keyCode == 'A') {
        joint_value_type = 2;
      }
      if (keyCode == 'T') {
        joint_value_type = 3;
      }
    }
    //events.add("Key press: " + key);
  }
  public void keyReleased() {
    ui.keyRelease(key);
  }
  public void keyTyped() {
    ui.keyType(key);
  }
  public void mouseEvent(MouseEvent e) {
    if(e.getAction() == MouseEvent.WHEEL) {
      if(events_label.contains(mouseX, mouseY)) {
        events_scroll += e.getCount();
      }
    }
    ui.mouseEvent(e);
  }
};

public void display_dial(PGraphics c, Rect r, float val, float minval, float maxval, int col) {
  fill(0);
  stroke(col);
  ellipse(r.x, r.y, r.w, r.h);
  noStroke();
  fill(col);
  arc(r.x, r.y, r.w, r.h, -HALF_PI, -HALF_PI+map(val, minval, maxval, 0, TAU), PIE);
  if (show_values || r.contains(mouseX, mouseY)) {
    c.push();
    c.translate(r.x, r.y-50);
    String valtext = String.format("%.10f", val);
    textSize(14);
    textAlign(LEFT, CENTER);
    float text_w = textWidth(valtext);
    float text_h = textAscent() + textDescent();
    c.fill(255);
    c.stroke(0);
    c.rect(-5, 0, text_w+10, text_h);
    c.fill(0);
    c.text(valtext, 0, 0, text_w, text_h);
    c.pop();
  }
}
// Points in relative positions from the top left of the view (like uv coordinates)
final float[][] state_points = {
  {0.8f, 0.8f},
  {0.6f, 0.65f},
  {0.65f, 0.1f},
  {0.525f, 0.325f},
  {0.4f, 0.5f},
  {0.25f, 0.15f},
  {0.1f, 0.35f}
};
// PGraphics c: used to display graphics
// PImage ur_img: square image of UR to display in the view
// Rect r: centered rectangle of the bounding area for this display
// double[] states: array of length 6, one value for each joint
// double minval, maxval: expected limits for the joint values
// double gripper: value for how open the gripper is, in radians (servo)
// int col: primary color of this joint state display
public void display_ur_joint_states(PGraphics c, PImage ur_img, Rect r, double[] states, double minval, double maxval, double gripper, int col) {
  Rect square = new Rect(r);
  square.w = min(r.w, r.h);
  square.h = square.w;
  square.x = square.x-square.w*0.5f;
  square.y = square.y-square.h*0.5f;
  c.pushStyle();
  c.rectMode(CORNER);
  c.imageMode(CORNER);
  c.image(ur_img, square.x, square.y, square.w, square.h);
  Rect dial = new Rect(0, 0, 50, 50);
  double[] allstates = new double[state_points.length];
  System.arraycopy(states, 0, allstates, 0, states.length);
  allstates[state_points.length-1] = gripper;
  for (int i = 0; i < state_points.length; i++) {
    float[] uv = state_points[i];
    float val = (float) allstates[i];
    boolean is_gripper = i == state_points.length-1;
    float m_minval = is_gripper ? 0.0f : (float) minval;
    float m_maxval = is_gripper ? 0.8248668046333418f : (float) maxval;
    int m_col = is_gripper ? GRIP_COL : col;
    float x = square.x + uv[0]*square.w;
    float y = square.y + uv[1]*square.h;
    dial.x = x;
    dial.y = y;
    display_dial(c, dial, val, m_minval, m_maxval, m_col);
  }
  c.popStyle();
}
Mode mode = new Mode() {
};
// Used to switch "scenes". Follows a state machine design pattern.
public abstract class Mode {
  Mode() {
    modes.add(this);
  }
  // setup needed to use PApplet methods during creation of a mode
  public void setup() {
  }
  public void onStart() {
  }
  public void update() {
  }
  public void draw() {
  }
  public void drawUI() {
  }
  public void mouseEvent(MouseEvent e) {
  }
  public void keyPressed() {
  }
  public void keyReleased() {
  }
  public void keyTyped() {
  }
  public void onEnd() {
  }
}

public void switchMode(Mode m) {
  if (m == null) return;
  mode.onEnd();
  mode = m;
  m.onStart();
}
class ModeGUI {
  ArrayList<Button> buttons;
  HashSet<TextEntry> fields;
  Button focus;
  TextEntry entry;
  ModeGUI() {
    buttons = new ArrayList<Button>();
    fields = new HashSet<TextEntry>();
  }
  public ModeGUI addButton(Button b) {
    buttons.add(b);
    return this;
  }
  public ModeGUI addField(TextEntry te) {
    buttons.add(te);
    fields.add(te);
    return this;
  }
  public void draw(PGraphics c) {
    for (int i = 0; i < buttons.size(); i++) {
      Button b = buttons.get(i);
      if (!b.isEnabled()) continue;
      b.draw(c);
    }
  }
  public boolean mouseEvent(MouseEvent e) {
    if (e.getAction() == MouseEvent.PRESS) {
      focus = null;
      entry = null;
      for (int i = buttons.size() - 1; i >= 0; i--) {
        Button b = buttons.get(i);
        if (!b.isEnabled()) continue;
        if (b.contains(e.getX(), e.getY())) {
          focus = b;
          if (fields.contains(focus)) {
            entry = (TextEntry) focus;
          }
          focus.press(e);
          break;
        }
      }
      return focus != null;
    }
    if (e.getAction() == MouseEvent.RELEASE) {
      if (focus != null && focus.isEnabled()) {
        focus.release(e);
        if (focus.contains(e.getX(), e.getY())) focus.click(e);
        if(entry != focus) focus = null;
      }
    }
    return false;
  }
  public void keyPress(int key) {
    if (entry == null || !entry.isEnabled()) return;
    if (key == 3) {
      setClipboardContents(entry.getText());
    } else if (key == 22) {
      String clip = getClipboardContents();
      if (clip != null) {
        for (int i = 0; i < clip.length(); i++) {
          entry.keyPress(clip.charAt(i));
        }
      }
    } else {
      entry.keyPress(key);
    }
  }
  public void keyRelease(int key) {
    if (entry == null || !entry.isEnabled()) return;
    entry.keyRelease(key);
  }
  public void keyType(int key) {
    if (entry == null || !entry.isEnabled()) return;
    entry.keyType(key);
  }
}
final double QUAT_EPSILON = 0.000001f;

public double quat_mag(double[] q) {
  return Math.sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
}

public boolean quat_dot_eq(double dotprod) {
  return dotprod > 1-QUAT_EPSILON;
}

public double quat_dot(double[] q1, double[] q2) {
  return (q1[0]*q2[0] + q1[1]*q2[1] + q1[2]*q2[2] + q1[3]*q2[3]);
}

public boolean quat_equals(double[] q1, double[] q2) {
  return quat_dot_eq(quat_dot(q1, q2));
}

public double[] quat_normalize(double[] q) {
  double invmag = 1.0f/quat_mag(q);
  double[] qn = new double[4];
  if (invmag > QUAT_EPSILON) {
    qn[0] = q[0]*invmag;
    qn[1] = q[1]*invmag;
    qn[2] = q[2]*invmag;
    qn[3] = q[3]*invmag;
  }
  return qn;
}

public double[] quat_invert(double[] q) {
  return new double[] {-q[0], -q[1], -q[2], q[3]};
}

public double[] quat_mult(double[] q1, double[] q2) {
  double[] q3 = new double[] {
    q1[0]*q2[3] + q1[3]*q2[0] + q1[1]*q2[2] - q1[2]*q2[1],
    q1[1]*q2[3] + q1[3]*q2[1] + q1[2]*q2[0] - q1[0]*q2[2],
    q1[2]*q2[3] + q1[3]*q2[2] + q1[0]*q2[1] - q1[1]*q2[0],
    q1[3]*q2[3] - q1[0]*q2[0] - q1[1]*q2[1] - q1[2]*q2[2]
  };
  return q3;
}

public double quat_angle_between(double[] q1, double[] q2) {
  //double dotprod = Math.max(Math.min(quat_dot(q1, q2), 1), -1);
  //return quat_dot_eq(dotprod) ? 0 : Math.acos(dotprod);
  double[] q1to2 = quat_mult(quat_invert(q1), q2);
  double angle = 2*Math.acos(q1to2[3]);
  if (angle > Math.PI) {
    angle -= 2.0f*Math.PI;
  } else if (angle < -Math.PI) {
    angle += 2.0f*Math.PI;
  }
  return Math.abs(angle);
}

public double[] quat_from_axis_angle(double x, double y, double z, double angle) {
  double len = Math.sqrt(x*x + y*y + z*z);
  if (len > 0.0f) {
    x /= len;
    y /= len;
    z /= len;
  }
  
  double half = angle*0.5f;
  double sin_val = Math.sin(half);
  double[] q = {
    x * sin_val,
    y * sin_val,
    z * sin_val,
    Math.cos(half)
  };
  double sign = q[3] < 0 ? -1.0f : 1.0f;
  for(int i = 0; i < q.length; i++) {
    q[i] *= sign;
  }
  return q;
}

public double[] quat_to_axis_angle(double[] q) {
  double mag = Math.sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
  if (mag > 0.0f) {
    double ax = q[0]/mag;
    double ay = q[1]/mag;
    double az = q[2]/mag;
    double angle = 2*Math.atan2(mag, q[3]);
    return new double[] { ax, ay, az, angle };
  }
  return new double[] {0, 0, 0, 0};
}

public PMatrix3D quat_to_mat(double[] q) {
  float x2 = (float) (q[0]+q[0]);
  float y2 = (float) (q[1]+q[1]);
  float z2 = (float) (q[2]+q[2]);
  float xx2 = (float) (q[0]*x2);
  float yy2 = (float) (q[1]*y2);
  float zz2 = (float) (q[2]*z2);
  float yz2 = (float) (q[1]*z2);
  float wx2 = (float) (q[3]*x2);
  float xy2 = (float) (q[0]*y2);
  float wz2 = (float) (q[3]*z2);
  float xz2 = (float) (q[0]*z2);
  float wy2 = (float) (q[3]*y2);
  PMatrix3D mat = new PMatrix3D(
    1-yy2-zz2, xy2+wz2, xz2-wy2, 0,
    xy2-wz2, 1-xx2-zz2, yz2+wx2, 0,
    xz2+wy2, yz2-wx2, 1-xx2-yy2, 0,
    0, 0, 0, 1
    );
  return mat;
}

public double[] quat_from_mat(PMatrix3D mat) {
  double x, y, z, w;
  if (mat.m00 + mat.m11 + mat.m22 > 0) {
    double t = mat.m00 + mat.m11 + mat.m22 + 1;
    double s = 0.5f/Math.sqrt(t);
    w = s*t;
    z = (mat.m01 - mat.m10)*s;
    y = (mat.m20 - mat.m02)*s;
    x = (mat.m12 - mat.m21)*s;
  } else if (mat.m00 > mat.m11 && mat.m00 > mat.m22) {
    double t = mat.m00 - mat.m11 - mat.m22 + 1;
    double s = 0.5f/Math.sqrt(t);
    x = s*t;
    y = (mat.m01 + mat.m10)*s;
    z = (mat.m20 + mat.m02)*s;
    w = (mat.m12 - mat.m21)*s;
  } else if (mat.m11 > mat.m22) {
    double t = -mat.m00 + mat.m11 - mat.m22 + 1;
    double s = 0.5f/Math.sqrt(t);
    y = s*t;
    x = (mat.m01 + mat.m10)*s;
    w = (mat.m20 - mat.m02)*s;
    z = (mat.m12 + mat.m21)*s;
  } else {
    double t = -mat.m00 - mat.m11 + mat.m22 + 1;
    double s = 0.5f/Math.sqrt(t);
    z = s*t;
    w = (mat.m01 - mat.m10)*s;
    x = (mat.m20 + mat.m02)*s;
    y = (mat.m12 + mat.m21)*s;
  }
  return new double[] {x, y, z, w};
}
// 1 timestamp, 6 joint positions, 6 joint velocities, 6 joint accelerations, 1 gripper joint position state
final int MATLAB_PACKET_SIZE = 20; // all entries have a size of 8 bytes

public byte[] createSimulinkMessage(LocalDateTime timestamp, double[] joint_states) {
  ByteBuffer packet = ByteBuffer.allocate(8*MATLAB_PACKET_SIZE);
  packet.order(ByteOrder.LITTLE_ENDIAN);
  // Use the epoch milliseconds as the data ID so the response from MATLAB is marked with a timestamp directly (useful for associating data between real and sim)
  packet.putLong(toEpochMillis(timestamp));
  // joint, velocities, accelerations
  for (int i = 0; i < 18; i++) {
    double target = joint_states[i];
    packet.putDouble(target*Math.PI/180.0f);
  }
  packet.putDouble(joint_states[18]);
  return packet.array();
}

public void readSimulinkResponse(Client c) {
  final int MSG_SIZE = 264;
  ByteBuffer buf = ByteBuffer.allocate(MSG_SIZE);
  buf.order(ByteOrder.LITTLE_ENDIAN);
  buf.put(c.readBytes(MSG_SIZE));
  long timestamp_millis = buf.getLong(0);
  // timestamp of -1 means data is not ready to publish
  if (timestamp_millis != -1) {
    simstate.tcp_x = buf.getDouble(8);
    simstate.tcp_y = buf.getDouble(16);
    simstate.tcp_z = buf.getDouble(24);
    // MATLAB has quaternions in w, x, y, z order, but we want x, y, z, w
    // But, now we recieve axis, angle
    //simstate.tcp_rot[3] = buf.getDouble(32);
    //simstate.tcp_rot[0] = buf.getDouble(40);
    //simstate.tcp_rot[1] = buf.getDouble(48);
    //simstate.tcp_rot[2] = buf.getDouble(56);
    double ax = buf.getDouble(32);
    double ay = buf.getDouble(40);
    double az = buf.getDouble(48);
    double angle = buf.getDouble(56);
    simstate.tcp_rot = quat_from_axis_angle(ax, ay, az, angle);
    
    int addr = 64;
    for (int i = 0; i < simstate.q.length; i++) {
      simstate.q[i] = buf.getDouble(addr);
      addr += 8;
    }
    for (int i = 0; i < simstate.w.length; i++) {
      simstate.w[i] = buf.getDouble(addr);
      addr += 8;
    }
    for (int i = 0; i < simstate.a.length; i++) {
      simstate.a[i] = buf.getDouble(addr);
      addr += 8;
    }
    for (int i = 0; i < simstate.t.length; i++) {
      simstate.t[i] = buf.getDouble(addr);
      addr += 8;
    }
    simstate.gq = buf.getDouble(addr);
    LocalDateTime timestamp = fromEpochMillis(timestamp_millis);
    //println("Recieved TCP [" + timestamp.toString() + "]: " + tcp_x + ", " + tcp_y + ", " + tcp_z + "; Axis-angle: " + tcp_rot_x + ", " + tcp_rot_y + ", " + tcp_rot_z + ", " + tcp_rot_angle);
    ur_sim_time = timestamp;
    synchronized(sim_states) {
      sim_states.put(ur_sim_time, new UR_State(simstate));
    }
    //ur_tcp_pos.set((float) tcp_x, (float)  tcp_y, (float) tcp_z);
    //ur_tcp_rot_axis.set((float) tcp_rot_x, (float) tcp_rot_y, (float) tcp_rot_z);
    //ur_tcp_rot_angle = tcp_rot_angle;
  }
}
public double average(List<Double> data) {
  if(data.size() == 0) return 0;
  double total = 0;
  for(double d : data) {
    total += d;
  }
  return total/data.size();
}

public double percentile(List<Double> data, double perc01) {
  int size = data.size();
  if(size == 0) return 0;
  ArrayList<Double> copy = new ArrayList<>(data);
  Collections.sort(copy);
  double target = (size-1)*Math.max(Math.min(perc01, 1), 0);
  int left = Math.max((int) target, 0);
  int right = Math.min((int) (target+1), size-1);
  double rightweight = (target%1.0f);
  double leftweight = 1-rightweight;
  return copy.get(left)*leftweight+copy.get(right)*rightweight;
}

public double median(List<Double> data) {
  if(data.size() == 0) return 0;
  ArrayList<Double> copy = new ArrayList<>(data);
  Collections.sort(copy);
  if(copy.size() % 2 == 0) {
    return (copy.get(copy.size()/2) + copy.get(copy.size()/2-1))*0.5f;
  } else {
    return copy.get(copy.size()/2);
  }
}

public double variance(List<Double> data) {
  double N = data.size();
  if(N == 0) return 0;
  double mean = average(data);
  double sse = 0;
  for(double d : data) {
    sse += (d - mean)*(d - mean);
  }
  return sse/(N-1);
}

public double max(List<Double> data) {
  if(data.size() == 0) return 0;
  double largest = Double.NEGATIVE_INFINITY;
  for(double d : data) {
    if (d > largest) largest = d;
  }
  return largest;
}

public double min(List<Double> data) {
  if(data.size() == 0) return 0;
  double smallest = Double.POSITIVE_INFINITY;
  for(double d : data) {
    if (d < smallest) smallest = d;
  }
  return smallest;
}

class UR_State {
  public double tcp_x, tcp_y, tcp_z;
  //public double tcp_rot_ax, tcp_rot_ay, tcp_rot_az, tcp_rot_angle;
  public double[] tcp_rot = new double[4]; // x, y, z, w
  public double[] q = new double[6]; // joint positions
  public double[] w = new double[6]; // joint velocities
  public double[] a = new double[6]; // joint accelerations
  public double[] t = new double[6]; // joint torques
  public double gq;
  public UR_State() {}
  
  public UR_State(UR_State src) {
    tcp_x = src.tcp_x;
    tcp_y = src.tcp_y;
    tcp_z = src.tcp_z;
    System.arraycopy(src.tcp_rot, 0, tcp_rot, 0, tcp_rot.length);
    System.arraycopy(src.q, 0, q, 0, q.length);
    System.arraycopy(src.w, 0, w, 0, w.length);
    System.arraycopy(src.a, 0, a, 0, a.length);
    System.arraycopy(src.t, 0, t, 0, t.length);
    gq = src.gq;
  }
}

public UR_State extractStateFromPlayback(SamplePlayback pb, UR_State s) {
  if (pb == null) return s;
  if (s == null) s = new UR_State();
  for(int i = 0; i < s.q.length; i++) {
    s.q[i] = pb.state[i+0]*Math.PI/180.0f;
  }
  for(int i = 0; i < s.w.length; i++) {
    s.w[i] = pb.state[i+6]*Math.PI/180.0f;
  }
  for(int i = 0; i < s.a.length; i++) {
    s.a[i] = pb.state[i+12]*Math.PI/180.0f;
  }
  for(int i = 0; i < s.t.length; i++) {
    s.t[i] = pb.state[i+19];
  }
  // Gripper states
  // pb.state[24]
  // pb.state[25]
  s.tcp_x = pb.state[25]*0.001f;
  s.tcp_y = pb.state[26]*0.001f;
  s.tcp_z = pb.state[27]*0.001f;
  // convert rotation format
  // create quaternion from axis-angle:
  double ax = 0, ay = 0, az = 0;
  ax = pb.state[31];
  ay = pb.state[32];
  az = pb.state[33];
  double a_len = Math.sqrt(ax*ax + ay*ay + az*az);
  if (a_len > 0.0f) {
    ax /= a_len;
    ay /= a_len;
    az /= a_len;
  }
  double[] quat = quat_from_axis_angle(ax, ay, az, a_len*Math.PI/180.0f);
  //PMatrix3D rot = new PMatrix3D();
  //rot.rotateZ((float) (pb.state[34]*Math.PI/180.0));
  //rot.rotateY((float) (pb.state[33]*Math.PI/180.0));
  //rot.rotateX((float) (pb.state[32]*Math.PI/180.0));
  //double[] quat = quat_from_mat(rot);
  System.arraycopy(quat, 0, s.tcp_rot, 0, quat.length);
  s.gq = (1-pb.state[18])*0.8248668046333418f;
  return s;
}

public SampleSequence extractUR5eSamples(XML[] components, String componentId, String sampleType, String sampleId) {
  XML component = findElementWithAttributeValue(components, "componentId", componentId);
  if (component == null) {
    return new SampleSequence(null, sampleType, sampleId); // sequence contains no data but retains metadata
  };
  XML samples = component.getChild("Samples");
  return new SampleSequence(samples, sampleType, sampleId);
}

public SampleSequence[] extractUR5e3DSamples(XML[] components, String componentId, String sampleType, String sampleId) {
  XML component = findElementWithAttributeValue(components, "componentId", componentId);
  if (component == null) {
    return flatten3DSampleSequence(null, sampleType, sampleId);
  };
  XML samples = component.getChild("Samples");
  return flatten3DSampleSequence(samples, sampleType, sampleId);
}

// extracts UR5e sequence data from an MTConnect XML document.
// returns null if the document does not have a device matching devicename.
public SampleSequence[] extractUR5eData(XML doc, String devicename) {
  // Find ur5e device stream
  XML streams_parent = doc.getChild("Streams");
  if (streams_parent == null) return null;
  XML[] streams = streams_parent.getChildren("DeviceStream");
  XML ur5e_device = findElementWithAttributeValue(streams, "uuid", devicename);
  if (ur5e_device == null) return null;
  // Extract data for each joint position. Do not fail if any data is missing.
  XML[] components = ur5e_device.getChildren("ComponentStream");
  ArrayList<SampleSequence> ur_seq = new ArrayList<SampleSequence>();
  // 0
  ur_seq.add(extractUR5eSamples(components, "a01", "Angle", "angle_j1"));
  ur_seq.add(extractUR5eSamples(components, "a02", "Angle", "angle_j2"));
  ur_seq.add(extractUR5eSamples(components, "a03", "Angle", "angle_j3"));
  ur_seq.add(extractUR5eSamples(components, "a04", "Angle", "angle_j4"));
  ur_seq.add(extractUR5eSamples(components, "a05", "Angle", "angle_j5"));
  ur_seq.add(extractUR5eSamples(components, "a06", "Angle", "angle_j6"));
  // 6
  ur_seq.add(extractUR5eSamples(components, "a01", "AngularVelocity", "vel_j1"));
  ur_seq.add(extractUR5eSamples(components, "a02", "AngularVelocity", "vel_j2"));
  ur_seq.add(extractUR5eSamples(components, "a03", "AngularVelocity", "vel_j3"));
  ur_seq.add(extractUR5eSamples(components, "a04", "AngularVelocity", "vel_j4"));
  ur_seq.add(extractUR5eSamples(components, "a05", "AngularVelocity", "vel_j5"));
  ur_seq.add(extractUR5eSamples(components, "a06", "AngularVelocity", "vel_j6"));
  // 12
  ur_seq.add(extractUR5eSamples(components, "a01", "AngularAcceleration", "acc_j1"));
  ur_seq.add(extractUR5eSamples(components, "a02", "AngularAcceleration", "acc_j2"));
  ur_seq.add(extractUR5eSamples(components, "a03", "AngularAcceleration", "acc_j3"));
  ur_seq.add(extractUR5eSamples(components, "a04", "AngularAcceleration", "acc_j4"));
  ur_seq.add(extractUR5eSamples(components, "a05", "AngularAcceleration", "acc_j5"));
  ur_seq.add(extractUR5eSamples(components, "a06", "AngularAcceleration", "acc_j6"));
  // 18
  ur_seq.add(extractUR5eSamples(components, "g_1", "Openness", "gripper_pos"));
  // 19
  ur_seq.add(extractUR5eSamples(components, "a01", "Torque", "tor_j1"));
  ur_seq.add(extractUR5eSamples(components, "a02", "Torque", "tor_j2"));
  ur_seq.add(extractUR5eSamples(components, "a03", "Torque", "tor_j3"));
  ur_seq.add(extractUR5eSamples(components, "a04", "Torque", "tor_j4"));
  ur_seq.add(extractUR5eSamples(components, "a05", "Torque", "tor_j5"));
  ur_seq.add(extractUR5eSamples(components, "a06", "Torque", "tor_j6"));
  // 25
  ur_seq.addAll(Arrays.asList(extractUR5e3DSamples(components, "g_1", "PositionCartesian", "posit_tcp")));
  ur_seq.add(extractUR5eSamples(components, "g_1", "Velocity", "vel_x"));
  ur_seq.add(extractUR5eSamples(components, "g_1", "Velocity", "vel_y"));
  ur_seq.add(extractUR5eSamples(components, "g_1", "Velocity", "vel_z"));
  // 31
  ur_seq.addAll(Arrays.asList(extractUR5e3DSamples(components, "g_1", "Orientation", "orient_tcp")));
  ur_seq.add(extractUR5eSamples(components, "g_1", "AngularVelocity", "ang_vel_rx"));
  ur_seq.add(extractUR5eSamples(components, "g_1", "AngularVelocity", "ang_vel_ry"));
  ur_seq.add(extractUR5eSamples(components, "g_1", "AngularVelocity", "ang_vel_rz"));
  
  SampleSequence[] seq_arr = new SampleSequence[ur_seq.size()];
  ur_seq.toArray(seq_arr);
  return seq_arr;
}
public class Event {
  HashSet<Runnable> listeners = new HashSet<>();
  
  public void add(Runnable r) {
    listeners.add(r);
  }
  
  public void remove(Runnable r) {
    listeners.remove(r);
  }
  
  public void call() {
    for(Runnable r : listeners) {
      r.run();
    }
  }
}

public class ArrayIndexComparator<T> implements Comparator<Integer>
{
    private final List<T> list;
    private final Comparator<T> comp;

    public ArrayIndexComparator(List<T> data, Comparator<T> comp)
    {
        list = data;
        if(comp == null) {
          this.comp = (a, b) -> {
            Comparable ca = (Comparable) a;
            Comparable cb = (Comparable) b;
            return ca.compareTo(cb);
          };
        } else {
          this.comp = comp;
        }
    }
    
    public ArrayIndexComparator(List<T> data) {
      this(data, null);
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[list.size()];
        for (int i = 0; i < list.size(); i++)
        {
            indexes[i] = i;
        }
        return indexes;
    }

    public int compare(Integer index1, Integer index2)
    {
      return comp.compare(list.get(index1), list.get(index2));
    }
}

public <T extends Comparable> Integer[] getSortedIndices(List<T> list) {
  ArrayIndexComparator<T> comp = new ArrayIndexComparator<>(list);
  Integer[] sorted_indices = comp.createIndexArray();
  Arrays.sort(sorted_indices, comp);
  return sorted_indices;
}

public <T> Integer[] getSortedIndices(List<T> list, Comparator<T> comparator) {
  ArrayIndexComparator<T> comp = new ArrayIndexComparator<>(list, comparator);
  Integer[] sorted_indices = comp.createIndexArray();
  Arrays.sort(sorted_indices, comp);
  return sorted_indices;
}

public <T> List<T> reorderedList(List<T> list, Integer[] indices) {
  List<T> sorted = new ArrayList(list.size());
  for(int i : indices) {
    sorted.add(list.get(i));
  }
  return sorted;
}

public LocalDateTime fromEpochMillis(long millis) {
  try {
    Instant inst = Instant.ofEpochMilli(millis);
    return LocalDateTime.ofInstant(inst, ZoneOffset.UTC);
  }
  catch(Exception e) {
    return LocalDateTime.MIN;
  }
}

public LocalDateTime min(LocalDateTime a, LocalDateTime b) {
  return a.compareTo(b) <= 0 ? a : b; 
}

public LocalDateTime max(LocalDateTime a, LocalDateTime b) {
  return a.compareTo(b) >= 0 ? a : b; 
}

public LocalDateTime parseUTC(String datestring) {
  Instant inst = Instant.parse(datestring);
  return LocalDateTime.ofInstant(inst, UTC_ZONE_ID);
}

final ZoneId UTC_ZONE_ID = ZoneId.of("Etc/UTC");

public long toEpochMillis(LocalDateTime time) {
  Instant inst = time.toInstant(ZoneOffset.UTC);
  try {
    return inst.toEpochMilli();
  }
  catch(Exception e) {
    return -1L;
  }
}

public double goodMod(double a, double b) {
  if (b == 0.0f) return 0.0f;
  return (a % b + b) % b;
}




public String getClipboardContents() {
  String result = "";
  Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
  // odd: the Object param of getContents is not currently used
  Transferable contents = clipboard.getContents(null);
  boolean hasTransferableText = (contents != null) && contents.isDataFlavorSupported(DataFlavor.stringFlavor);
  if (hasTransferableText && contents != null) {
    try {
      result = (String) contents.getTransferData(DataFlavor.stringFlavor);
    } 
    catch (Exception ex) {
      //System.out.println(ex);
      //ex.printStackTrace();
    }
  }
  return result;
}

public void setClipboardContents(String str) {
  StringSelection stringSelection = new StringSelection(str);
  Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
  clipboard.setContents(stringSelection, null);
}
public void printXML(XML doc) {
  printXML(doc, 2);
}

public void printXML(XML doc, int indent) {
  println(doc.format(indent));
}

public XML findElementWithAttributeValue(XML[] elements, String attrName, String attrValue) {
  if (elements == null || attrName == null || attrValue == null) return null;
  for (XML x : elements) {
    if (x.hasAttribute(attrName) && attrValue.equals(x.getString(attrName))) {
      return x;
    }
  }
  return null;
}

public XML nonNullXML(XML maybe) {
  if (maybe == null) return parseXML("<empty></empty>");
  return maybe;
}


  public void settings() { size(800, 750, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "MTC_to_Simulink_Adapter_Analysis_Differential" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
